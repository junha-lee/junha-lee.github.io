<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no"/>


<title>Redis의 SCAN은 어떻게 동작하는가?</title>
<meta name="title" content="Redis의 SCAN은 어떻게 동작하는가?" />
<meta name="author" content="clark.kang"/>
<meta name="description" content="Redis의 기능 중에 쓰면 안되지만, 그 단맛에 끌려 어쩔 수 없이 치게 되는 명령이 KEYS입니다. KEYS를 쓰는 순간, Redis는 이 명령을 처리하기 위해서 멈춰버립니다. 특히 트래픽이 많은 서버는 이 KEYS 명령 하나 때문에 많은 장애를 내게 됩니다. 그런데 어느 순간(!) Redis에 SCAN이라는 명령이 생겼습니다. KEYS의 단점을 없애면서도, 느리지 않은 SCAN, 어떻게 그것이 가능할까요? 이 글에서는 단순한 SCAN의 사용법을 넘어, 소스 코드를 통해 동작 원리까지 알아보겠습니다. SCAN/SSCAN/ZSCAN/HSCAN 명령 대부분의 Redis 명령처럼 SCAN도 네가지 변형이 있습니다. SCAN은..."/>

<meta property="fb:app_id" content="1204347326263800"/>

<meta property="og:site_name" content="kakao 기술 블로그"/>
<meta property="og:type" content="article"/>
<meta property="og:title" content="Redis의 SCAN은 어떻게 동작하는가?"/>
<meta property="og:description" content="Redis의 기능 중에 쓰면 안되지만, 그 단맛에 끌려 어쩔 수 없이 치게 되는 명령이 KEYS입니다. KEYS를 쓰는 순간, Redis는 이 명령을 처리하기 위해서 멈춰버립니다. 특히 트래픽이 많은 서버는 이 KEYS 명령 하나 때문에 많은 장애를 내게 됩니다. 그런데 어느 순간(!) Redis에 SCAN이라는 명령이 생겼습니다. KEYS의 단점을 없애면서도, 느리지 않은 SCAN, 어떻게 그것이 가능할까요? 이 글에서는 단순한 SCAN의 사용법을 넘어, 소스 코드를 통해 동작 원리까지 알아보겠습니다. SCAN/SSCAN/ZSCAN/HSCAN 명령 대부분의 Redis 명령처럼 SCAN도 네가지 변형이 있습니다. SCAN은..."/>
<meta property="og:url" content="http://localhost:4000/2016/03/11/redis-scan/"/>
<meta property="og:image" content="http://localhost:4000/files/covers/observatory.jpg"/>
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:title" content="Redis의 SCAN은 어떻게 동작하는가?"/>
<meta name="twitter:description" content="Redis의 기능 중에 쓰면 안되지만, 그 단맛에 끌려 어쩔 수 없이 치게 되는 명령이 KEYS입니다. KEYS를 쓰는 순간, Redis는 이 명령을 처리하기 위해서 멈춰버립니다. 특히 트래픽이 많은 서버는 이 KEYS 명령 하나 때문에 많은 장애를 내게 됩니다. 그런데 어느 순간(!) Redis에 SCAN이라는 명령이 생겼습니다. KEYS의 단점을 없애면서도, 느리지 않은 SCAN, 어떻게 그것이 가능할까요? 이 글에서는 단순한 SCAN의 사용법을 넘어, 소스 코드를 통해 동작 원리까지 알아보겠습니다. SCAN/SSCAN/ZSCAN/HSCAN 명령 대부분의 Redis 명령처럼 SCAN도 네가지 변형이 있습니다. SCAN은..."/>
<meta name="twitter:label1" content="Written by"/>
<meta name="twitter:data1" content="clark.kang"/>
<meta name="twitter:image:src" content="http://localhost:4000/files/covers/observatory.jpg"/>

<meta name="twitter:label2" content="Filed under"/>
<meta name="twitter:data2" content="redis,redis-scan,redis-keys"/>

<meta property="article:tag" content="redis"/>

<meta property="article:tag" content="redis-scan"/>

<meta property="article:tag" content="redis-keys"/>



<meta property="article:published_time" content="2016-03-11T11:12:00+09:00"/>


<meta property="article:author" content="http://localhost:4000/authors/clark.kang"/>

<link href="http://localhost:4000/rss/" rel="alternate" type="application/rss+xml" title="RSS"/>
<link href="/assets/favicon.ico" rel="shortcut icon" type="image/vnd.microsoft.icon"/>
<link href="/assets/apple-touch-icon.png" rel="apple-touch-icon" type="image/png"/>
<link href="/assets/apple-touch-icon.png" rel="apple-touch-icon-precomposed" type="image/png"/>
<link href="/assets/lib/normalize.css" rel="stylesheet" type="text/css"/>
<link href="/assets/css/monokai.css" rel="stylesheet" type="text/css"/> 
<link href="/assets/lib/magnific-popup.min.css" rel="stylesheet" type="text/css"/>
<link href="/assets/fonts/Kakao.css" rel="stylesheet" type="text/css"/> 
<link href="/assets/css/screen.css" rel="stylesheet" type="text/css"/>
<script>
    if (window.location.host.indexOf('tech.kakao.com') > -1 && window.location.protocol == "https:"){
        window.location = window.location.toString().replace(/^https:/, "http:");
    }
</script>

</head>
<body class="post-template">

<div id="header">
    <button id="menu-toggle" type="button">
        <span class="sr-only">Toggle Navigation Menu</span>
    </button>
    <button id="search-toggle" type="button">
        <span class="sr-only">Toggle Search Form</span>
    </button>
    <a id="logo" href="/">
        <span class="sr-only">KakaoTech</span>
    </a>
    <div id="search">
        <input id="search-input" type="search" placeholder="Search..." value="" />
    </div>
    <ul class="search__results" id="results-container"></ul>

    <ul id="menu" class="nav">
        <li class=" active "><a href="/">블로그</a></li>
        <li class=""><a href="/opensource/">오픈소스</a></li>
        <li class=""><a href="/openapi/">오픈API</a></li>
        <li class=""><a href="/events/">기술행사</a></li>
    </ul>
</div>
<!-- Script pointing to jekyll-search.js -->
<script src="/dest/jekyll-search.js" type="text/javascript"></script>

<script type="text/javascript">
    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: '/search2.json',
        searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>',
        noResultsText: '<li>No results found</li>',
        limit: 15,
        fuzzy: false,
        exclude: ['Welcome']
    })
</script><!-- #header -->



<div id="wrapper">
    <div id="navbar" class="container">
  <h5><a id="link-back" href="/">Back to Posts</a></h5>
  
<ul id="shares">
    <li class="stalk" style="display:none">
        <a id="kakao-link-btn" href="javascript:;"></a>
    </li>
    <li>
        <a id="share-kakaostory" href="javascript:shareStory('http://localhost:4000/2016/03/11/redis-scan/');"></a>
    </li>

    
    <li>
        <a id="share-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/2016/03/11/redis-scan/"
           onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
            <span class="sr-only">Share to Facebook</span>
        </a>
    </li>
    
    
    <li>
        <a id="share-twitter"
           href="https://twitter.com/intent/tweet?text=Redis%EC%9D%98%20SCAN%EC%9D%80%20%EC%96%B4%EB%96%BB%EA%B2%8C%20%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80?&url=http://localhost:4000/2016/03/11/redis-scan/">
            <span class="sr-only">Share to Twitter</span>
        </a>
    </li>
    
    
    <li>
        <a id="share-google" href="https://plus.google.com/share?url=http://localhost:4000/2016/03/11/redis-scan/"
           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
            <span class="sr-only">Share to Google+</span>
        </a>
    </li>
    
</ul>

</div>

<div id="cover" class="container" style="background-image: url(/files/covers/observatory.jpg);" >
  <div>
    <h1>Redis의 SCAN은 어떻게 동작하는가?</h1>
    <p>
      
      <a href="/tags/redis">redis</a>
      ,
      
      <a href="/tags/redis-scan">redis-scan</a>
      ,
      
      <a href="/tags/redis-keys">redis-keys</a>
      
      
    </p>
    


  </div>
</div>

<div id="content" class="container post" role="main">
  <div id="post-content"><p><img src="http://item-kr.talk.kakao.co.kr/do/2FPpx81E0V62RDSr-GVgQXaq4FJCveCBKCNZV-bZscw_/872b56c06d9ac5bc264419e187b346041667fc7b08261b4c493670baa83d5cb9" class="pull-right" />
<a href="http://redis.io">Redis</a>의 기능 중에 쓰면 안되지만, 그 단맛에 끌려 어쩔 수 없이 치게 되는 명령이 <a href="http://redis.io/commands/keys">KEYS</a>입니다. KEYS를 쓰는 순간, Redis는 이 명령을 처리하기 위해서 멈춰버립니다. 특히 트래픽이 많은 서버는 이 KEYS 명령 하나 때문에 많은 장애를 내게 됩니다.
그런데 어느 순간(!) Redis에 <a href="http://redis.io/commands/scan">SCAN</a>이라는 명령이 생겼습니다. KEYS의 단점을 없애면서도, 느리지 않은 SCAN, 어떻게 그것이 가능할까요? 이 글에서는 단순한 SCAN의 사용법을 넘어, 소스 코드를 통해 동작 원리까지 알아보겠습니다.</p>

<h2 id="scansscanzscanhscan-명령">SCAN/SSCAN/ZSCAN/HSCAN 명령</h2>

<p>대부분의 Redis 명령처럼 SCAN도 네가지 변형이 있습니다. <a href="http://redis.io/commands/scan">SCAN</a>은 전체 key 목록에서, <a href="http://redis.io/commands/sscan">SSCAN</a>은 set 안에서, <a href="http://redis.io/commands/zscan">ZSCAN</a>은 sorted set 안에서, <a href="http://redis.io/commands/hscan">HSCAN</a>은 hash 안에서 키를 가져오는 명령입니다:</p>

<ul>
  <li><code class="highlighter-rouge">SCAN cursor [MATCH pattern] [COUNT count]</code></li>
  <li><code class="highlighter-rouge">SSCAN key cursor [MATCH pattern] [COUNT count]</code></li>
  <li><code class="highlighter-rouge">ZSCAN key cursor [MATCH pattern] [COUNT count]</code></li>
  <li><code class="highlighter-rouge">HSCAN key cursor [MATCH pattern] [COUNT count]</code></li>
</ul>

<p><strong>cursor 값을 0으로 지정한 SCAN/SSCAN/ZSCAN/HSCAN 명령으로 순회가 시작</strong>되고, 이어지는 순회에 사용할 cursor 값과, 지정한 패턴(pattern)과 일치하는 키를 최대 지정한 갯수(count)만큼 반환합니다. <strong>반환된 cursor 값이 0이면 순회가 종료</strong>됩니다. 이 과정을 <strong>전체 순회(full iteration)</strong>이라고 합니다. 다음은 CLI에서 SCAN 명령을 사용하여 전체 순회를 하는 예입니다:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">redis 127.0.0.1:6379&gt;</span> scan 0 &lt;<span class="nt">--</span> cursor 값 0으로 순회 시작.
<span class="go">1) "17" &lt;-- 이어지는 scan 명령에 사용할 cursor 값
2)  1) "key:12"
    2) "key:8"
    3) "key:4"
    4) "key:14"
    5) "key:16"
    6) "key:17"
    7) "key:15"
    8) "key:10"
    9) "key:3"
   10) "key:7"
   11) "key:1"
</span><span class="gp">redis 127.0.0.1:6379&gt;</span> scan 17 &lt;<span class="nt">--</span> 앞의 scan 명령의 응답으로 반환된 cursor 값
<span class="go">1) "0" &lt;-- 반환된 cursor 값이 0이면 순회 종료(전체 순회).
2) 1) "key:5"
   2) "key:18"
   3) "key:0"
   4) "key:2"
   5) "key:19"
   6) "key:13"
   7) "key:6"
   8) "key:9"
   9) "key:11"
</span></code></pre></div></div>

<p>앞의 scan 명령의 결과에 따라 이어지는 scan 명령에 사용할 cursor 값이 바뀌고 이 값에 따라 순회 종료 여부를 판단해야 하므로 CLI보다는 스크립트에서 더욱 유용합니다. 다음은 Redis에서 모든 키 목록을 가져오는 파이썬 코드입니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">redis</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">redis</span><span class="o">.</span><span class="n">StrictRedis</span><span class="p">(</span><span class="s">'localhost'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">)</span>
<span class="n">init</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># cursor 값 0으로 스캔 시작</span>
<span class="k">while</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">init</span>
    <span class="n">init</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c"># 이어지는 scan 명령에 사용할 cursor 값</span>
    <span class="k">print</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">init</span> <span class="o">==</span> <span class="s">'0'</span><span class="p">):</span> <span class="c"># 반환된 cursor 값이 0이면 스캔 종료</span>
        <span class="k">break</span>
</code></pre></div></div>

<p>위 예제의 결과는 KEYS 명령과 기본적으로 동일하지만, <strong>항상 그렇지는 않습니다</strong> 항상 그렇지는 않다뇨?! 뭐가 다른거죠? 왜 다른거죠? 그래서… Redis의 소스를 뒤져보았습니다.</p>

<h2 id="redis의-스캔-구현">Redis의 스캔 구현</h2>

<p>모든 스캔 명령(SCAN/SSCAN/ZSCAN/HSCAN)은 <code class="highlighter-rouge">scanGenericCommand</code>라는 공통 함수를 이용해서 처리가 됩니다:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">scanGenericCommand</span><span class="p">(</span><span class="n">redisClient</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">robj</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cursor</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">......</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">o</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">REDIS_SET</span> <span class="o">&amp;&amp;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">REDIS_ENCODING_HT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">REDIS_HASH</span> <span class="o">&amp;&amp;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">REDIS_ENCODING_HT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
        <span class="n">count</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* We return key / value for this type. */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">REDIS_ZSET</span> <span class="o">&amp;&amp;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">REDIS_ENCODING_SKIPLIST</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zset</span> <span class="o">*</span><span class="n">zs</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">;</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">zs</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">;</span>
        <span class="n">count</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* We return key / value for this type. */</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ht</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

        <span class="cm">/* We pass two pointers to the callback: the list to which it will
         * add new elements, and the object containing the dictionary so that
         * it is possible to fetch more data in a type-dependent way. */</span>
        <span class="n">privdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys</span><span class="p">;</span>
        <span class="n">privdata</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">cursor</span> <span class="o">=</span> <span class="n">dictScan</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">scanCallback</span><span class="p">,</span> <span class="n">privdata</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cursor</span> <span class="o">&amp;&amp;</span> <span class="n">listLength</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">REDIS_SET</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int64_t</span> <span class="n">ll</span><span class="p">;</span>

        <span class="k">while</span><span class="p">(</span><span class="n">intsetGet</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">pos</span><span class="o">++</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ll</span><span class="p">))</span>
            <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span><span class="n">createStringObjectFromLongLong</span><span class="p">(</span><span class="n">ll</span><span class="p">));</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">REDIS_HASH</span> <span class="o">||</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">REDIS_ZSET</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ziplistIndex</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vstr</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vlen</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">vll</span><span class="p">;</span>

        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ziplistGet</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vstr</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vlen</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vll</span><span class="p">);</span>
            <span class="n">listAddNodeTail</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span>
                <span class="p">(</span><span class="n">vstr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="n">createStringObject</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">vstr</span><span class="p">,</span><span class="n">vlen</span><span class="p">)</span> <span class="o">:</span>
                                 <span class="n">createStringObjectFromLongLong</span><span class="p">(</span><span class="n">vll</span><span class="p">));</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">ziplistNext</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">redisPanic</span><span class="p">(</span><span class="s">"Not handled encoding in SCAN."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">......</span>
</code></pre></div></div>

<p>위의 코드에서 핵심적인 부분은, 찾아야 하는 key들을 <code class="highlighter-rouge">keys</code>라는 리스트에 추가하고, 이 리스트를 돌면서 패턴에 맞는 것들을 삭제한 결과를 돌려줍니다. 당연히 Redis는 다양한 자료구조를 지원하고 있고, 속도를 위해서 같은 자료구조라도 구현 방식이 여러가지입니다. 그러나 이것 전부라면 이 글을 쓰지 않았겠죠. 삽질을 계속하기 위해, 먼저 “Redis가 어떻게 데이터를 저장하는지”부터 다시 한번 살펴 보겠습니다.</p>

<h2 id="redis의-자료구조">Redis의 자료구조</h2>

<p>Redis의 가장 기초적인 자료구조는 KV 즉 Key/Value 형태를 저장하는 것입니다.(String 타입이라고도 합니다.) 이를 위해 Redis는 <strong>Bucket을 활용한 Chained Linked List 구조</strong>를 사용합니다. 최초에는 4개의 Bucket에서 사용하며, 같은 Bucket에 들어가는 Key는 링크드 리스트 형태로 저장하는 거죠. 즉 다음 그림과 같습니다.</p>

<p><img src="https://charsyam.files.wordpress.com/2015/01/redis_hash_1.png" alt="redis_hash_1" /></p>

<p>이 Chained Linked List에는 약점이 있습니다. 한 Bucket 안에 데이터가 많아지면 결국 탐색 속도가 느려집니다. 이를 위해서 Redis는 특정 사이즈가 넘을 때 마다 Bucket을 두 배로 확장하고, Key들을 rehash하게 됩니다. 먼저 이 때 Key의 Hash로 사용하는 해시함수는 다음과 같습니다. <a href="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash2</a>를 사용합니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* MurmurHash2, by Austin Appleby
 * Note - This code makes a few assumptions about how your machine behaves -
 * 1. We can read a 4-byte value from any address without crashing
 * 2. sizeof(int) == 4
 *
 * And it has a few limitations -
 *
 * 1. It will not work incrementally.
 * 2. It will not produce the same results on little-endian and big-endian
 *    machines.
 */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">dictGenHashFunction</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 'm' and 'r' are mixing constants generated offline.
     They're not really 'magic', they just happen to work well.  */</span>
    <span class="kt">uint32_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">dict_hash_function_seed</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">m</span> <span class="o">=</span> <span class="mh">0x5bd1e995</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>

    <span class="cm">/* Initialize the hash to a 'random' value */</span>
    <span class="kt">uint32_t</span> <span class="n">h</span> <span class="o">=</span> <span class="n">seed</span> <span class="o">^</span> <span class="n">len</span><span class="p">;</span>

    <span class="cm">/* Mix 4 bytes at a time into the hash */</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">k</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

        <span class="n">k</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">k</span> <span class="o">^=</span> <span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">k</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>

        <span class="n">h</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">h</span> <span class="o">^=</span> <span class="n">k</span><span class="p">;</span>

        <span class="n">data</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Handle the last few bytes of the input array  */</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="n">h</span> <span class="o">^=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="n">h</span> <span class="o">^=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="n">h</span> <span class="o">^=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">h</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="cm">/* Do a few final mixes of the hash to ensure the last few
     * bytes are well-incorporated. */</span>
    <span class="n">h</span> <span class="o">^=</span> <span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">;</span>
    <span class="n">h</span> <span class="o">*=</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">h</span> <span class="o">^=</span> <span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">h</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그리고 hash 값이 들어가야 할 hash table 내의 <code class="highlighter-rouge">index</code>를 결정하는 방법은 다음과 같습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Returns the index of a free slot that can be populated with
 * a hash entry for the given 'key'.
 * If the key already exists, -1 is returned.
 *
 * Note that if we are in the process of rehashing the hash table, the
 * index is always returned in the context of the second (new) hash table. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_dictKeyIndex</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">......</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">table</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
        <span class="p">......</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">table</code>에는 Key를 찾기위해 비트 연산을 하기 위한 <code class="highlighter-rouge">sizemask</code>가 들어가 있습니다. 초기에는 <code class="highlighter-rouge">table</code>의 bucket이 <code class="highlighter-rouge">4</code>개 이므로 <code class="highlighter-rouge">sizemask</code>는
이진수로 <code class="highlighter-rouge">11</code> 즉 <code class="highlighter-rouge">3</code>의 값이 셋팅됩니다. 즉 <code class="highlighter-rouge">해시된 결과 &amp; 11</code>의 연산결과로 들어가야 하는 Bucket이 결정되게 됩니다.</p>

<p>여기서 Key가 많아지면 Redis는 Table의 사이즈를 <code class="highlighter-rouge">2</code>배로 늘리게 됩니다. 그러면 당연히 <code class="highlighter-rouge">sizemask</code>도 커지게 됩니다. Table size가 <code class="highlighter-rouge">8</code>이면 <code class="highlighter-rouge">sizemask</code>는 <code class="highlighter-rouge">7</code>이 됩니다.</p>

<p>먼저 간단하게 말하자면, <strong>SCAN의 원리는 이 Bucket을 한 턴에 하나씩 순회</strong>하는 것입니다. 그래서 아래 그림과 같이 처음에는 Bucket Index <code class="highlighter-rouge">0</code>를 읽고 데이터를 던져주는 것입니다.</p>

<p><img src="https://charsyam.files.wordpress.com/2015/01/redis_scan_0.png" alt="redis_scan_0" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">m0</span> <span class="o">=</span> <span class="n">t0</span><span class="o">-&gt;</span><span class="n">sizemask</span><span class="p">;</span>

<span class="cm">/* Emit entries at cursor */</span>
<span class="n">de</span> <span class="o">=</span> <span class="n">t0</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">m0</span><span class="p">];</span>
<span class="k">while</span> <span class="p">(</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fn</span><span class="p">(</span><span class="n">privdata</span><span class="p">,</span> <span class="n">de</span><span class="p">);</span>
    <span class="n">de</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="redis의-re-hashing">Redis의 ​Re-hashing</h2>

<p>이번에는 Redis SCAN의 동작을 더 분석하기 위해서 Redis Hash Table의 Rehashing과, 그 상황에서 SCAN이 어떻게 동작하는지 알아보도록 하겠습니다. 앞에서도 간단하게 언급했지만 Redis Hash Table은 보통 Dynamic Bucket에 충돌은 list로 처리하는 방식입니다.</p>

<p><img src="https://charsyam.files.wordpress.com/2015/01/redis_hash_1.png" alt="redis_hash_1" /></p>

<p>처음에는 <code class="highlighter-rouge">4</code>개의 Bucket으로 진행하면 Hash 값에 <code class="highlighter-rouge">bitmask</code>를 씌워서 Hash Table 내의 <code class="highlighter-rouge">index</code>를 결정합니다. 그런데, 이대로 계속 데이터가 증가하면, 당연히 충돌이 많고, List가 길어지므로, 탐색 시간이 오래걸리게 되어서 문제가 발생합니다. Redis는 이를 해결하기 위해서 hash table의 사이즈를 <code class="highlighter-rouge">2</code>배로 늘리는 정책을 취합니다.</p>

<p><img src="https://charsyam.files.wordpress.com/2015/01/redis_hash_expand.png" alt="redis_hash_expand" /></p>

<p><code class="highlighter-rouge">2</code>배로 테이블이 늘어나면서, <code class="highlighter-rouge">bitmask</code>는 하나 더 사용하도록 됩니다. 이렇게 테이블이 확장되면 Rehash를 하게 됩니다. 그래야만 검색시에 제대로 찾을 수 있기 때문입니다. 먼저 Table을 확장할 때 사용하는 것이 <code class="highlighter-rouge">_dictExpandIfNeeded</code> 합수입니다. <code class="highlighter-rouge">dictIsRehashing</code>는 이미 Rehash 중인지를 알려주는 함수이므로, Rehashing 중이면 이미 테이블이 확장된 상태이므로 그냥 <code class="highlighter-rouge">DICT_OK</code>를 리턴합니다.</p>

<p>먼저 hash table에서 hash table의 사용 정도가 <code class="highlighter-rouge">dict_force_resize_ratio</code> 값 보다 높으면 <code class="highlighter-rouge">2</code>배로 확장하게 됩니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Expand the hash table if needed */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_dictExpandIfNeeded</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Incremental rehashing already in progress. Return. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>

    <span class="cm">/* If the hash table is empty expand it to the initial size. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">dictExpand</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">DICT_HT_INITIAL_SIZE</span><span class="p">);</span>

    <span class="cm">/* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the "safe" threshold, we resize doubling
     * the number of buckets. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">dict_can_resize</span> <span class="o">||</span>
         <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span><span class="o">/</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">dict_force_resize_ratio</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">dictExpand</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>실제로 <code class="highlighter-rouge">_dictExpandIfNeeded</code>는 <code class="highlighter-rouge">_dictKeyIndex</code> 함수에서 호출하게 됩니다. 이렇게 테이블이 확장되면 Rehash를 해야 합니다. Rehash라는 것은 테이블의 Bucket 크기가 커졌고 bitmask가 달라졌으니… mask <code class="highlighter-rouge">0011</code>이 전부 3번째 index였다면 이중에서 <code class="highlighter-rouge">111</code>은 7번째로, <code class="highlighter-rouge">011</code>은 3번째로 옮기는 것입니다. 여기서 Redis의 특징이 하나 있습니다. 한꺼번에 모든 테이블을 Rehashing 해야 하면 당연히 시간이 많이 걸립니다. <strong>O(n)</strong>의 시간이 필요합니다. 그래서 Redis는 rehash flag와 <code class="highlighter-rouge">rehashidx</code>라는 변수를 이용해서, hash table에서 하나씩 Rehash하게 됩니다. 즉, 확장된 크기가 8이라면 이전 크기 총 4번의 Rehash 스텝을 통해서 Rehashing이 일어나게 됩니다. (이로 인해서 뒤에서 설명하는 특별한 현상이 생깁니다.)</p>

<p>그리고 현재 rehashing 중인것을 체크하는 함수가 <code class="highlighter-rouge">dictIsRehashing</code> 함수입니다. <code class="highlighter-rouge">rehashidx</code>가 <code class="highlighter-rouge">-1</code>이 아니면 Rehashing 중인 상태입니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define dictIsRehashing(d) ((d)-&gt;rehashidx != -1)
</span></code></pre></div></div>

<p>그리고 위의 <code class="highlighter-rouge">_dictExpandIfNeeded</code>에서 호출하는 실제 hash table의 크기를 증가시키는 <code class="highlighter-rouge">dictExpand</code> 함수에서 <code class="highlighter-rouge">rehashidx</code>를 <code class="highlighter-rouge">0</code>으로 설정합니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Expand or create the hash table */</span>
<span class="kt">int</span> <span class="nf">dictExpand</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">dictht</span> <span class="n">n</span><span class="p">;</span> <span class="cm">/* the new hash table */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">realsize</span> <span class="o">=</span> <span class="n">_dictNextPower</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

    <span class="cm">/* the size is invalid if it is smaller than the number of
     * elements already inside the hash table */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">||</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DICT_ERR</span><span class="p">;</span>

    <span class="cm">/* Allocate the new hash table and initialize all pointers to NULL */</span>
    <span class="n">n</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">realsize</span><span class="p">;</span>
    <span class="n">n</span><span class="p">.</span><span class="n">sizemask</span> <span class="o">=</span> <span class="n">realsize</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">n</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">zcalloc</span><span class="p">(</span><span class="n">realsize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dictEntry</span><span class="o">*</span><span class="p">));</span>
    <span class="n">n</span><span class="p">.</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Is this the first initialization? If so it's not really a rehashing
     * we just set the first hash table so that it can accept keys. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Prepare a second hash table for incremental rehashing */</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 함수를 잘 살펴보면 <code class="highlighter-rouge">dict</code> 구조체 안의 <code class="highlighter-rouge">ht[1] = n</code>으로 할당하는 코드가 있습니다. 이 얘기는 hash table이 두 개라는 것입니다. 먼저 <code class="highlighter-rouge">dict</code> 구조체를 살펴보면 다음과 같습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span> <span class="p">{</span>
    <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span>
    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">long</span> <span class="n">rehashidx</span><span class="p">;</span> <span class="cm">/* rehashing not in progress if rehashidx == -1 */</span>
    <span class="kt">int</span> <span class="n">iterators</span><span class="p">;</span> <span class="cm">/* number of iterators currently running */</span>
<span class="p">}</span> <span class="n">dict</span><span class="p">;</span>
</code></pre></div></div>

<p>실제로, redis의 rehashing 중에는 Hash Table이 두개가 존재합니다. 이것은 앞에 설명했듯이… 한번에 rehash step이 끝나지 않고, 매번 하나의 bucket 별로 rehashing을 하기 때문입니다. 즉 hash table의 확장이 일어나면 다음과 같이 두 개의 hash table 이 생깁니다.</p>

<p><img src="https://charsyam.files.wordpress.com/2015/01/redis_hash_expand_1.png" alt="redis_hash_expand_1" /></p>

<p>그리고 한 스텝이 자나갈 때 마다 하나의 Bucket 단위로 해싱이 됩니다. 즉 첫번째 rehash step에서는 다음과 같이 <code class="highlighter-rouge">ht[0]</code>에 있던 데이터들이 <code class="highlighter-rouge">ht[1]</code>으로 나뉘어서 들어가게 됩니다.</p>

<p><img src="https://charsyam.files.wordpress.com/2015/01/redis_hash_rehash_11.png" alt="redis_hash_rehash_1" /></p>

<p>두 번째, 세 번째, 네 번째 rehash 스텝이 끝나면 완료되게 됩니다.</p>

<p><img src="https://charsyam.files.wordpress.com/2015/01/redis_hash_rehash_21.png" alt="redis_hash_rehash_2" /></p>

<p>그럼 의문이 생깁니다. Rehashing 중에 추가 되는 데이터는? 또는 삭제나 업데이트는? 추가 되는 데이터는 이 때는 무조건 <code class="highlighter-rouge">ht[1]</code>으로 들어가게 됩니다.(또 해싱 안해도 되게…) 두 번째로, 검색이나 업데이트는?? 이 때는 <code class="highlighter-rouge">ht[0]</code>, <code class="highlighter-rouge">ht[1]</code>을 모두 탐색하게 됩니다.(어쩔 수 없겠죠?)</p>

<p><code class="highlighter-rouge">dictRehash</code> 함수에서 이 rehash step을 처리하게 됩니다. <code class="highlighter-rouge">dictRehash</code> 함수의 파라매터 <code class="highlighter-rouge">n</code>은 이 스텝을 몇 번이나 할 것인가 이고, 실제로 수행할 hash table의 index는 함수 중에서 <code class="highlighter-rouge">ht[0]</code>의 table이 <code class="highlighter-rouge">NULL</code>인 부분을 스킵하면서 찾게 됩니다. 그리고 <code class="highlighter-rouge">ht[0]</code>의 <code class="highlighter-rouge">used</code> 값이 <code class="highlighter-rouge">0</code>이면 rehash가 모두 끝난것이므로 <code class="highlighter-rouge">ht[1]</code>을 <code class="highlighter-rouge">ht[0]</code>로 변경하고 <code class="highlighter-rouge">rehashidx</code>를 다시 <code class="highlighter-rouge">-1</code>로 셋팅하면서 종료하게 됩니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table. */</span>
<span class="kt">int</span> <span class="nf">dictRehash</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span> <span class="o">*</span><span class="n">nextde</span><span class="p">;</span>

        <span class="cm">/* Check if we already rehashed the whole table... */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">zfree</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">_dictReset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="o">++</span><span class="p">;</span>
        <span class="n">de</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">];</span>
        <span class="cm">/* Move all the keys in this bucket from the old to the new hash HT */</span>
        <span class="k">while</span><span class="p">(</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>

            <span class="n">nextde</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="cm">/* Get the index in the new hash table */</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
            <span class="n">de</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">de</span><span class="p">;</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span><span class="o">--</span><span class="p">;</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">nextde</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 다시 SCAN으로 돌아오면… Rehashing 중의 <code class="highlighter-rouge">dictScan</code> 함수는 다음과 같습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

    <span class="cm">/* Make sure t0 is the smaller and t1 is the bigger table */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t0</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">t1</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">m0</span> <span class="o">=</span> <span class="n">t0</span><span class="o">-&gt;</span><span class="n">sizemask</span><span class="p">;</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">-&gt;</span><span class="n">sizemask</span><span class="p">;</span>

    <span class="cm">/* Emit entries at cursor */</span>
    <span class="n">de</span> <span class="o">=</span> <span class="n">t0</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">m0</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fn</span><span class="p">(</span><span class="n">privdata</span><span class="p">,</span> <span class="n">de</span><span class="p">);</span>
        <span class="n">de</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Iterate over indices in larger table that are the expansion
     * of the index pointed to by the cursor in the smaller table */</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="cm">/* Emit entries at cursor */</span>
        <span class="n">de</span> <span class="o">=</span> <span class="n">t1</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">m1</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fn</span><span class="p">(</span><span class="n">privdata</span><span class="p">,</span> <span class="n">de</span><span class="p">);</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Increment bits not covered by the smaller mask */</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">(((</span><span class="n">v</span> <span class="o">|</span> <span class="n">m0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">m0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">m0</span><span class="p">);</span>

        <span class="cm">/* Continue while bits covered by mask difference is non-zero */</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">m0</span> <span class="o">^</span> <span class="n">m1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>실제로 이미 Rehashing이 된 bucket의 경우는 <code class="highlighter-rouge">ht[0]</code> 작은 hash table에는 이미 <code class="highlighter-rouge">index</code>의 값이 <code class="highlighter-rouge">NULL</code>이므로 실제로 돌지 않지만, 아직 rehash되지 않은 bucket의 경우는 <code class="highlighter-rouge">ht[0]</code> 와 <code class="highlighter-rouge">ht[1]</code>의 두 군데, 즉 총 세 군데에 데이터가 존재할 수 있습니다. 그래서 먼저 <code class="highlighter-rouge">ht[0]</code>의 bucket을 돌고 나서, <code class="highlighter-rouge">ht[1]</code>을 찾게 됩니다. 여기서 당연히 <code class="highlighter-rouge">ht[1]</code>에서는 두 군데를 검색해야 하므로 두 번 돌게 됩니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v</span> <span class="o">=</span> <span class="p">(((</span><span class="n">v</span> <span class="o">|</span> <span class="n">m0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">m0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">m0</span><span class="p">);</span>
</code></pre></div></div>

<p>즉 위의 식은 만약 <code class="highlighter-rouge">v</code>가 <code class="highlighter-rouge">0</code>이고 <code class="highlighter-rouge">m0 = 3, m1 = 7</code>이라고 하면 <code class="highlighter-rouge">(((0 | 3) + 1) &amp; ~3) | (0 &amp; 3)</code>이 됩니다. <code class="highlighter-rouge">~3</code>은 Bitwise NOT 3이 되므로 <code class="highlighter-rouge">-4</code>이고, <code class="highlighter-rouge">(4 &amp; -4) | 0</code>이므로, 결론은 <code class="highlighter-rouge">4 &amp; -4</code> 입니다. <code class="highlighter-rouge">3</code>은 <code class="highlighter-rouge">00000011</code>, bitwise NOT하면 <code class="highlighter-rouge">11111100</code>이므로, <code class="highlighter-rouge">00000100 &amp; 11111100</code> 해서 <code class="highlighter-rouge">00000100</code>, 즉 <code class="highlighter-rouge">4</code>가 됩니다. 처음에는 index <code class="highlighter-rouge">0</code>, 두번째는 index <code class="highlighter-rouge">4</code>가 되는 거죠. 그래서 첫 루프를 돌게 됩니다. 다시 <code class="highlighter-rouge">4 &amp; (m0 ^ m1) == 4</code> 이므로…</p>

<p>이제 두 번째 루프에서 다시 <code class="highlighter-rouge">(((4 | 3) + 1) &amp; -4) | (4 &amp; 3)</code>이고 <code class="highlighter-rouge">4 | 3 = 7, 4 &amp; 3 = 0</code>이고, 다시 한번 정리하면 <code class="highlighter-rouge">((7+1) &amp; -4) | 0</code> 이므로 결론은 <code class="highlighter-rouge">8 &amp; -4 = 4</code> 가 되고, <code class="highlighter-rouge">00001000 &amp; 111111100</code>이 되므로 <code class="highlighter-rouge">v</code> 는 이번에는 <code class="highlighter-rouge">00001000</code>, 즉 <code class="highlighter-rouge">8</code>이 됩니다. 즉 한번 돌 때 마다, <code class="highlighter-rouge">ht[0]</code>의 <code class="highlighter-rouge">size</code> 만큼 증가하게 됩니다.(다들 한 방에 이해하실 텐데… 이걸 설명한다고 Orz) 그래서 그 다음번에는 <code class="highlighter-rouge">8 &amp; 4</code> 가 되므로 루프가 끝나게 됩니다. 즉, 0, 4 이렇게 <code class="highlighter-rouge">ht[1]</code>에서 두 번 읽어야 하니, 두 번 읽는 코드를 만들어둔거죠.</p>

<h2 id="redis의-scan과-cursor">Redis의 SCAN과 cursor</h2>

<p>결국 Redis SCAN에서의 <strong>Cursor는 bucket 을 검색해야할 다음 index 값</strong>이라고 볼 수 있습니다. 그런데 실제로 실행시켜보면, 0, 1, 2 이렇게 증가하지 않습니다.</p>

<p>그 이유 중에 하나는 실제 Cursor 값이 <strong>다음 index의 reverse 값</strong>을 취하고 있기 때문입니다. 이걸 보기 전에 먼저 다시 한번 SCAN의 핵심 함수인 <code class="highlighter-rouge">dictScan</code>을 살펴보도록 하겠습니다.(맨 뒤만 보면 됩니다.)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">dictScan</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span>
                       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">,</span>
                       <span class="n">dictScanFunction</span> <span class="o">*</span><span class="n">fn</span><span class="p">,</span>
                       <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">dictht</span> <span class="o">*</span><span class="n">t0</span><span class="p">,</span> <span class="o">*</span><span class="n">t1</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dictSize</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">m0</span> <span class="o">=</span> <span class="n">t0</span><span class="o">-&gt;</span><span class="n">sizemask</span><span class="p">;</span>

        <span class="cm">/* Emit entries at cursor */</span>
        <span class="n">de</span> <span class="o">=</span> <span class="n">t0</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">v</span> <span class="o">&amp;</span> <span class="n">m0</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">de</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fn</span><span class="p">(</span><span class="n">privdata</span><span class="p">,</span> <span class="n">de</span><span class="p">);</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="p">......</span>
    <span class="p">}</span>

    <span class="cm">/* Set unmasked bits so incrementing the reversed cursor
     * operates on the masked bits of the smaller table */</span>
    <span class="n">v</span> <span class="o">|=</span> <span class="o">~</span><span class="n">m0</span><span class="p">;</span>

    <span class="cm">/* Increment the reverse cursor */</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">rev</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">v</span><span class="o">++</span><span class="p">;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">rev</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>한 이터레이션이 끝나고 나면 <code class="highlighter-rouge">m0</code> 의 bitwise NOT을 or 하고 reverse를 취한 다음 <code class="highlighter-rouge">1</code>을 더하고 다시 reverse를 취합니다. 일단 bucket이 <code class="highlighter-rouge">4</code>개만 있다고 가정하고, rehashing은 빼고 생각해보도록 합니다. 먼저 여기서 reverse는 비트를 쭈욱 세워놓고, 그걸 거꾸로 뒤집는 것입니다.
그래서 <code class="highlighter-rouge">0</code>의 <code class="highlighter-rouge">rev(0)</code> 은 그대로 <code class="highlighter-rouge">0</code>이고, <code class="highlighter-rouge">rev(1)</code>은 <code class="highlighter-rouge">8000000000000000</code>(16진수), <code class="highlighter-rouge">rev(2)</code>는 <code class="highlighter-rouge">4000000000000000</code>(16진수)가 됩니다.</p>

<p>처음에는 <code class="highlighter-rouge">v</code>(cursor)가 <code class="highlighter-rouge">0</code>입니다. scan이 끝나고 <code class="highlighter-rouge">(0 |= ~3) = -4</code>, 그 뒤에 <code class="highlighter-rouge">rev(-4)</code>는 <code class="highlighter-rouge">3fffffffffffffff</code>(16진수) 가 됩니다. 여기에 <code class="highlighter-rouge">1</code>을 더하면 <code class="highlighter-rouge">4000000000000000</code> 여기서 다시 <code class="highlighter-rouge">rev(4000000000000000)</code>가 되면 <code class="highlighter-rouge">2</code>가 나오게 됩니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Function to reverse bits. Algorithm from:
 * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">rev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// bit size; must be power of 2
</span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">s</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mask</span> <span class="o">^=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">);</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">((</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그런데 왜 reverse를 취하는 것일까요? 이것은 실제 적으로 1씩 증가하는 형태라면… cursor가 언제 끝나는지 알려주기가 애매해서 입니다. 즉 끝났다는 값을 다시 줘야 하는데, 그것보다는 0으로 시작해서 다시 0으로 끝날 수 있도록 reverse 형태를 취하는 것이죠.</p>

<h2 id="결론">결론</h2>

<p>Redis의 <a href="http://redis.io/commands/scan">SCAN</a>명령은 싱글쓰레드 아키텍쳐에서 <a href="http://redis.io/commands/smembers">KEYS</a>와 <a href="http://redis.io/commands/smembers">SMEMBERS</a> 명령이 가진 문제점을 해결한 유용한 명령입니다. 그러나, 빛이 있는 곳에는 그림자가 있기 마련! SCAN 명령도 여러가지 문제점이 있습니다:</p>

<ol>
  <li>기본적으로 scan 의 경우 table 의 한 블럭을 가져오는 것이라서, 여기에 개수가 많으면 시간이 많이 걸릴 수도 있습니다.(다만, 리해싱 테이블이 bitmasking 크기만큼 커지므로, 한 블럭이 극단적으로 커질 가능성은 높지 않습니다.)</li>
  <li>set/sorted set/hash 의 내부 구조가 hash table 이나 skiplist 가 아닐 경우(ziplist 로 구현되어 있을 경우), 한 컬렉션의 모든 데이터를 가져오므로, <code class="highlighter-rouge">KEYS</code> 명령과 비슷한 문제가 그대로 발생할 수 있습니다.</li>
  <li>명령의 옵션으로 count 값을 지정할 수 있지만, 정확히 그 개수를 보장하지 않습니다.</li>
  <li>순회가 시작(cursor 값을 0으로 지정한 scan 명령)된 이후에 추가된 항목은 전체 순회(full iteration; scan 명령의 반환된 cursor값이 0)가 끝날 때까지 반환되지 않습니다(cursor가 이미 지나갔으므로).</li>
  <li>hash table이 확장/축소/rehashing 될 때 다시 스캔하지 않기 때문 같은 항목이 여러 번 반환 될 수 있습니다. 반환된 키 값으로 다른 명령을 실행하려면 주의해야 합니다.</li>
</ol>

<p><img src="http://item-kr.talk.kakao.co.kr/do/2FPpx81E0V62RDSr-GVgQXaq4FJCveCBKCNZV-bZscw_/99618dd778b732ede66ee6359f9ee65b1667fc7b08261b4c493670baa83d5cb9" class="pull-right" />
“Redis의 SCAN은 어떻게 동작할까”라는 단순한 호기심에서 출발해서 Redis의 코드를 여기저기 살펴보았습니다. 어떤가요? 별거 없죠? 부족한 글이지만 이 글을 통해서, 유명한 오픈소스라고 해서 기죽지 않고 소스 코드를 뒤져보고 직접 확인하는 재미를 발견하셨길 바랍니다.</p>

<blockquote>
  <p>이 글은 자칭 “혀로그래머” <a href="https://github.com/charsyam">clark.kang</a>의 블로그  <a href="https://charsyam.wordpress.com/2014/02/04/redis-scansscanzscanhscan-이야기/">Scan/SScan/ZScan/HScan 이야기…</a>와 “Redis Scan은 어떻게 동작할까?” 시리즈 <a href="https://charsyam.wordpress.com/2015/01/15/입-개발-redis-scan은-어떻게-동작할까/">1부</a>, <a href="https://charsyam.wordpress.com/2015/01/18/입개발-redis-scan은-어떻게-동작할까-part-2/">2부</a>, <a href="https://charsyam.wordpress.com/2015/01/20/입개발-redis-scan은-어떻게-동작할까-part-3결/">3부</a>를 원저자의 동의를 받아 엮은 글입니다.</p>
</blockquote>

<ul>
  <li>커버 이미지 출처: <a href="https://www.flickr.com/photos/esoastronomy/">European Southern Observatory</a> © <a href="https://flic.kr/p/dWUuum">The new PARLA laser in operation at ESO’s Paranal Observatory</a></li>
</ul>
</div>
  <div id="post-footer">
    
    <a id="post-author" href="/authors/clark.kang/">
      <div id="author-image" style="background-image:url(/files/authors/clark.kang.jpg);">
        <span class="sr-only">clark.kang's profile image</span>
      </div>
      <p id="author-name">clark.kang</p>
    </a>
    <p id="post-date">2016-03-11 11:12</p>
    <a id="post-more" href="/authors/clark.kang/">
      <span>Read more posts by this author</span>
    </a>
  </div>
</div>

<div class="container" style="margin-top:25px; padding:0px">
  <a href="https://www.welcomekakao.com" target="_blank"><img src="/files/career2020.jpg" style="width:100%;"></a>
</div>

<div id="post-links" class="container">
  
  
  <div id="post-prev" style="background-image: url(/files/covers/monad.jpg);" >
    <div>
      <h3><a href="/2016/03/03/monad-programming-with-scala-future/">Monad Programming with Scala Future</a></h3>
      <p>YOU MIGHT ENJOY</p>
    </div>
  </div>
  
  
  
  <div id="post-next" style="background-image: url(/files/covers/offcuts.jpg);" >
    <div>
      <h3><a href="/2016/03/11/opensource-3-hri/">kakao의 오픈소스 Ep3 - HBase Region Inspector</a></h3>
      <p>NEXT POST</p>
    </div>
  </div>
  
</div>

<div id="lightbox">
  <div id="lightbox-image"></div>
</div>

    <div class="clearfix"></div>

    <a href="#" id="back-to-top"></a>
</div>

<div id="footer" class="container-fluid">
    <ul id="links">
        
        <li>
            <a id="link-github" href="http://github.com/kakao" target="_blank">
                <span class="sr-only">github</span>
            </a>
        </li>
        
        
        <li>
            <a id="link-facebook" href="http://facebook.com/nkakao" target="_blank">
                <span class="sr-only">facebook</span>
            </a>
        </li>
        
        
        <li>
            <a id="link-twitter" href="http://twitter.com/kakaodev" target="_blank">
                <span class="sr-only">twitter</span>
            </a>
        </li>
        
        <li>
            <a id="link-rss" href="/rss" target="_blank">
                <span class="sr-only">rss</span>
            </a>
        </li>
    </ul>
    <ul id="footer-menu">
        <li><a href="//www.kakaocorp.com">Kakao</a></li>
        <li><a href="//careers.kakao.com/jobs">Jobs</a></li>
        <li><a href="//privacy.kakaocorp.com">Privacy</a></li>
    </ul>
    <p id="copyright">
        <a href="//www.kakaocorp.com">Copyright &copy; Kakao Corp.</a>
        All rights reserved.
    </p>
</div><!--#footer-->


<script src="/assets/lib/jquery-1.12.0.min.js"></script>
<script src="/assets/lib/jquery.magnific-popup.min.js"></script>
<script src="/assets/js/index.js"></script>
<script src="//developers.kakao.com/sdk/js/kakao.min.js"></script>


<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date();
        a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-72007721-1', 'auto');
    ga('send', 'pageview');
</script>




    <script type='text/javascript'>
   //<![CDATA[
    // 사용할 앱의 JavaScript 키를 설정해 주세요.
    //Kakao.init('65d48e116d8b9409e08960c4800c3017');
    function shareStory(abs_page_url) {
        Kakao.Story.share({
            url: abs_page_url,
            text: '카카오 기술블로그 #개발자 #카카오'
        });
    }
    //]]>
</script>

    
    <script>
window.fbAsyncInit = function() {
  FB.init({
    appId      : '1204347326263800',
    xfbml      : true,
    version    : 'v2.7'
  });
};

(function(d, s, id){
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script>

    

    
    <script>!function (d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location) ? 'http' : 'https';
        if (!d.getElementById(id)) {
            js = d.createElement(s);
            js.id = id;
            js.src = p + '://platform.twitter.com/widgets.js';
            fjs.parentNode.insertBefore(js, fjs);
        }
    }(document, 'script', 'twitter-wjs');
</script>

    

    
    <script src="https://apis.google.com/js/platform.js" async defer>
    {
        lang: 'ko'
    }
</script>

    

</body>
</html>
