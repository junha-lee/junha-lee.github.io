<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no"/>


<title>Parallel Programming and Applicative in Scala</title>
<meta name="title" content="Parallel Programming and Applicative in Scala" />
<meta name="author" content="liam.m"/>
<meta name="description" content="Monolithic 아키텍쳐로 개발하기 Monolithic 아키텍쳐로 개발시에는 일반적으로 하나의 저장소만 고려해야 하는 경우가 많았습니다. Monolithic 아키텍쳐를 사용하면 편리한점이 많습니다. 코드가 한곳에 모여 있고 데이터가 한곳에 집중이 되어 있다는 것입니다. 일반적인 정규화 된 테이블에서 상품과 관련된 정보를 가져온다고 가정해보겠습니다. 데이터는 여러개의 테이블로 쪼개져 있기 때문에 필요한 데이터를 조합이 필요하다면 아래와 같이 SQL을 이용해서 여러개의 테이블을 join해서 데이터를 조합하여 가져올 수 있습니다. SELECT * FROM items, catalogs, wishes, categories, details, certificiations WHERE items.id = ? AND items.id =..."/>

<meta property="fb:app_id" content="1204347326263800"/>

<meta property="og:site_name" content="kakao 기술 블로그"/>
<meta property="og:type" content="article"/>
<meta property="og:title" content="Parallel Programming and Applicative in Scala"/>
<meta property="og:description" content="Monolithic 아키텍쳐로 개발하기 Monolithic 아키텍쳐로 개발시에는 일반적으로 하나의 저장소만 고려해야 하는 경우가 많았습니다. Monolithic 아키텍쳐를 사용하면 편리한점이 많습니다. 코드가 한곳에 모여 있고 데이터가 한곳에 집중이 되어 있다는 것입니다. 일반적인 정규화 된 테이블에서 상품과 관련된 정보를 가져온다고 가정해보겠습니다. 데이터는 여러개의 테이블로 쪼개져 있기 때문에 필요한 데이터를 조합이 필요하다면 아래와 같이 SQL을 이용해서 여러개의 테이블을 join해서 데이터를 조합하여 가져올 수 있습니다. SELECT * FROM items, catalogs, wishes, categories, details, certificiations WHERE items.id = ? AND items.id =..."/>
<meta property="og:url" content="http://localhost:4000/2017/09/02/parallel-programming-and-applicative-in-scala/"/>
<meta property="og:image" content="http://localhost:4000/files/covers/monad.jpg"/>
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:title" content="Parallel Programming and Applicative in Scala"/>
<meta name="twitter:description" content="Monolithic 아키텍쳐로 개발하기 Monolithic 아키텍쳐로 개발시에는 일반적으로 하나의 저장소만 고려해야 하는 경우가 많았습니다. Monolithic 아키텍쳐를 사용하면 편리한점이 많습니다. 코드가 한곳에 모여 있고 데이터가 한곳에 집중이 되어 있다는 것입니다. 일반적인 정규화 된 테이블에서 상품과 관련된 정보를 가져온다고 가정해보겠습니다. 데이터는 여러개의 테이블로 쪼개져 있기 때문에 필요한 데이터를 조합이 필요하다면 아래와 같이 SQL을 이용해서 여러개의 테이블을 join해서 데이터를 조합하여 가져올 수 있습니다. SELECT * FROM items, catalogs, wishes, categories, details, certificiations WHERE items.id = ? AND items.id =..."/>
<meta name="twitter:label1" content="Written by"/>
<meta name="twitter:data1" content="liam.m"/>
<meta name="twitter:image:src" content="http://localhost:4000/files/covers/monad.jpg"/>

<meta name="twitter:label2" content="Filed under"/>
<meta name="twitter:data2" content="parallel,applicative,scala,async,functional-programming"/>

<meta property="article:tag" content="parallel"/>

<meta property="article:tag" content="applicative"/>

<meta property="article:tag" content="scala"/>

<meta property="article:tag" content="async"/>

<meta property="article:tag" content="functional-programming"/>



<meta property="article:published_time" content="2017-09-02T12:57:00+09:00"/>


<meta property="article:author" content="http://localhost:4000/authors/liam.m"/>

<link href="http://localhost:4000/rss/" rel="alternate" type="application/rss+xml" title="RSS"/>
<link href="/assets/favicon.ico" rel="shortcut icon" type="image/vnd.microsoft.icon"/>
<link href="/assets/apple-touch-icon.png" rel="apple-touch-icon" type="image/png"/>
<link href="/assets/apple-touch-icon.png" rel="apple-touch-icon-precomposed" type="image/png"/>
<link href="/assets/lib/normalize.css" rel="stylesheet" type="text/css"/>
<link href="/assets/css/monokai.css" rel="stylesheet" type="text/css"/> 
<link href="/assets/lib/magnific-popup.min.css" rel="stylesheet" type="text/css"/>
<link href="/assets/fonts/Kakao.css" rel="stylesheet" type="text/css"/> 
<link href="/assets/css/screen.css" rel="stylesheet" type="text/css"/>
<script>
    if (window.location.host.indexOf('tech.kakao.com') > -1 && window.location.protocol == "https:"){
        window.location = window.location.toString().replace(/^https:/, "http:");
    }
</script>

</head>
<body class="post-template">

<div id="header">
    <button id="menu-toggle" type="button">
        <span class="sr-only">Toggle Navigation Menu</span>
    </button>
    <button id="search-toggle" type="button">
        <span class="sr-only">Toggle Search Form</span>
    </button>
    <a id="logo" href="/">
        <span class="sr-only">KakaoTech</span>
    </a>
    <div id="search">
        <input id="search-input" type="search" placeholder="Search..." value="" />
    </div>
    <ul class="search__results" id="results-container"></ul>

    <ul id="menu" class="nav">
        <li class=" active "><a href="/">블로그</a></li>
        <li class=""><a href="/opensource/">오픈소스</a></li>
        <li class=""><a href="/openapi/">오픈API</a></li>
        <li class=""><a href="/events/">기술행사</a></li>
    </ul>
</div>
<!-- Script pointing to jekyll-search.js -->
<script src="/dest/jekyll-search.js" type="text/javascript"></script>

<script type="text/javascript">
    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: '/search2.json',
        searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>',
        noResultsText: '<li>No results found</li>',
        limit: 15,
        fuzzy: false,
        exclude: ['Welcome']
    })
</script><!-- #header -->



<div id="wrapper">
    <div id="navbar" class="container">
  <h5><a id="link-back" href="/">Back to Posts</a></h5>
  
<ul id="shares">
    <li class="stalk" style="display:none">
        <a id="kakao-link-btn" href="javascript:;"></a>
    </li>
    <li>
        <a id="share-kakaostory" href="javascript:shareStory('http://localhost:4000/2017/09/02/parallel-programming-and-applicative-in-scala/');"></a>
    </li>

    
    <li>
        <a id="share-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/2017/09/02/parallel-programming-and-applicative-in-scala/"
           onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
            <span class="sr-only">Share to Facebook</span>
        </a>
    </li>
    
    
    <li>
        <a id="share-twitter"
           href="https://twitter.com/intent/tweet?text=Parallel%20Programming%20and%20Applicative%20in%20Scala&url=http://localhost:4000/2017/09/02/parallel-programming-and-applicative-in-scala/">
            <span class="sr-only">Share to Twitter</span>
        </a>
    </li>
    
    
    <li>
        <a id="share-google" href="https://plus.google.com/share?url=http://localhost:4000/2017/09/02/parallel-programming-and-applicative-in-scala/"
           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
            <span class="sr-only">Share to Google+</span>
        </a>
    </li>
    
</ul>

</div>

<div id="cover" class="container" style="background-image: url(/files/covers/monad.jpg);" >
  <div>
    <h1>Parallel Programming and Applicative in Scala</h1>
    <p>
      
      <a href="/tags/parallel">parallel</a>
      ,
      
      <a href="/tags/applicative">applicative</a>
      ,
      
      <a href="/tags/scala">scala</a>
      ,
      
      <a href="/tags/async">async</a>
      ,
      
      <a href="/tags/functional-programming">functional-programming</a>
      
      
    </p>
    


  </div>
</div>

<div id="content" class="container post" role="main">
  <div id="post-content"><h3 id="monolithic-아키텍쳐로-개발하기">Monolithic 아키텍쳐로 개발하기</h3>
<p><a href="http://microservices.io/patterns/monolithic.html">Monolithic 아키텍쳐</a>로 개발시에는 일반적으로 하나의 저장소만 고려해야 하는 경우가 많았습니다.</p>

<p>Monolithic 아키텍쳐를 사용하면 편리한점이 많습니다.
코드가 한곳에 모여 있고 데이터가 한곳에 집중이 되어 있다는 것입니다.
일반적인 정규화 된 테이블에서 상품과 관련된 정보를 가져온다고 가정해보겠습니다.
데이터는 여러개의 테이블로 쪼개져 있기 때문에 필요한 데이터를 조합이 필요하다면 아래와 같이 SQL을 이용해서 여러개의 테이블을 join해서 데이터를 조합하여  가져올 수 있습니다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span>
  <span class="n">items</span><span class="p">,</span> <span class="n">catalogs</span><span class="p">,</span> <span class="n">wishes</span><span class="p">,</span> <span class="n">categories</span><span class="p">,</span> <span class="n">details</span><span class="p">,</span> <span class="n">certificiations</span>
<span class="k">WHERE</span>
    <span class="n">items</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="o">?</span>
<span class="k">AND</span> <span class="n">items</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">catalogs</span><span class="p">.</span><span class="n">itemId</span>
<span class="k">AND</span> <span class="n">items</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">wishes</span><span class="p">.</span><span class="n">itemId</span>
<span class="p">...</span>
</code></pre></div></div>

<p>단순함을 가지고 있는 Monolithic은 장점도 많이 있지만 단점이 많은 개발 방법론입니다.
하나의 코드 베이스안에서 모든것이 관리 되기 때문에 경계선이 애매하고 많은 컴포넌트가 서로 의존을 가지고 강결합을 이루고 있게 됩니다.
코드가 늘어남에 따라 시스템은 무거워지고 조금만 고쳐도 여러곳에서 side effect가 생기며 외부 변화에 빠르게 대처하지 못하게 됩니다.</p>

<p>이런 단점을 극복하기 위해서 <a href="https://martinfowler.com/articles/microservices.html">마이크로 서비스</a>란 개념이 <a href="https://en.wikipedia.org/wiki/Microservices#History">2011년도</a>에 나오고 그 이후 패러다임이 바뀌게 되었습니다.
특히 Netflix와 같은 실리콘 밸리의 유명한 IT기업에 이를 <a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/">전폭적으로 사용</a>하고 이에 대한 성공 사례를 보여주며
많은 기업과 소프트웨어 개발자들이 이 아키텍쳐를 채택 해야하는 근거를 제시해주었습니다.
이제 마이크로 서비스는 많은 관심을 가지고 <a href="https://medium.com/microhq/why-companies-adopt-microservices-and-how-they-succeed-2ad32f39c65a">엔터프라이즈 시장에서 인기</a>를 가지고 있는 아키텍쳐 입니다.
아래 통계자료를 보면 75% 이상이 마이크로 서비스를 일부 혹은 전면적으로 사용하며 개발하고 있습니다.</p>

<p><img src="http://i.imgur.com/zMjBCRx.jpg" alt="" /></p>
<ul>
  <li>이미지 출처 : <a href="https://jaxenter.com/microservices-trends-2017-survey-133265.html">Microservices trends 2017: Strategies, tools and frameworks</a></li>
</ul>

<h3 id="마이크로-서비스로-개발하기---데이터의-분리">마이크로 서비스로 개발하기 - 데이터의 분리</h3>

<p>마이크로 서비스로 개발하는 것은 무조건 좋고 장점만 있는 것은 아닙니다.
마이크로 서비스로 개발 방법론 을 한다는 것은 과거의 <a href="http://microservices.io/patterns/monolithic.html">Monolithic 아키텍쳐</a>로 하나의 저장소만 관리하는것과 완전 다른 개발 방식을 가져오게 되었습니다.
각각의 마이크로 서비스는 독립적으로 동작하기 때문에 자신만의 고유한 데이터를 가지고 있습니다.
즉 많은 데이터는 각각의 마이크로 서비스로 분산 됩니다.</p>

<p><img src="http://i.imgur.com/qzwSwHK.png" alt="Monolithic vs microservices architecture" /></p>
<ul>
  <li>이미지 출처 : <a href="http://3gamma.com/insights/architecting-speed-agile-innovators-accelerate-growth-microservices/">Architecting for speed: How agile innovators accelerate growth through microservices</a></li>
</ul>

<p>Monolithic으로 개발시에는 메인의 DB에 <a href="https://www.smartdraw.com/entity-relationship-diagram/">ER Diagram</a>만 잘알면 되었지만
다른 마이크로 서비스의 데이터는 어디에 어떤 테이블로 저장되어었는지 알 필요가 없습니다.
도메인이 분리 되었기 때문에 다른 마이크로 서비스의 API의 스펙 관리 하고 이를 쉽게 호출 할수 있어야 해야 합니다.
이를 위해 Rest API는 documentation을 잘 보여주는 <a href="https://swagger.io/">Swagger</a>, RPC의 <a href="https://thrift.apache.org/">Thrift</a> 그리고 <a href="https://grpc.io/">GRPC</a>와 같은 도구로 API Spec을 주로 표현합니다.
물론 API Spec을 관리하는 다른 방법도 많이 있습니다.</p>

<p>분리된 데이터를 합치고 구성하기 위해서 <a href="http://microservices.io/patterns/apigateway.html">API Gateway</a>에서 여러곳에 마이크로 서비스의 정의된 API를 호출하여 분산되어 있는 다양한 정보를 가져와서 조합을 해야합니다.</p>

<h2 id="순차-연동-방식">순차 연동 방식</h2>
<p>예를 들어 마이크로 서비스에서 정보를 얻기 위해서 10개의 API에서 정보를 가져와야 할 경우가 있다고 해보겠습니다.
이를 동기화 방식으로 처리를 한다면 각각의 API가 100 ms의 응답을 준다면 <strong>1초의 딜레이</strong>가 생기게 됩니다.
마이크로 서비스가 좋다고 했는데 SQL 한번 호출하고 200ms이면 되던 API가 <strong>5배나 느려졌습니다</strong>.</p>

<p><img src="http://i.imgur.com/2qx57hH.png" alt="" /></p>
<ul>
  <li>이미지 출처 : Reactive Microservices Architecture By Jonas Bonér, Co-Founder &amp; CTO Lightbend, Inc.</li>
</ul>

<p>혹자는 과거(Monolithic)가 더 좋다며 이런걸 왜 쓰냐고 하는 경우도 있습니다.
하지만 마이크로 서비스의 느슨한 결합의 장점은 쉽게 뿌리 칠수가 없습니다.
코드에 한번 들어간 SQL 조인 쿼리는 시스템과 강결합 되어서 쉽게 고칠수 없고 리팩토링및 시스템을 유지보수 하기 여간 어려운것이 아닙니다.</p>

<p>문제를 해결하기 위해 블로킹 연산 말고 <code class="highlighter-rouge">Future</code>의 비동기 연산을 사용하면 상황이 달라지지 않을까요?</p>

<h3 id="future-monad를-이용한-비동기-연동-방식">Future Monad를 이용한 비동기 연동 방식</h3>

<p>이전 글(<a href="http://tech.kakao.com/2016/05/04/asynchronous-programming-and-monad-transformers-in-scala/">Asynchronous Programming and Monad Transformers in Scala</a>)은 <code class="highlighter-rouge">Monad</code>를 이용한 비동기 연동방식
Future Monad의 <code class="highlighter-rouge">flatMap</code>을 이용하여서 비동기 프로그래밍을 실행할 수 있는 방법을 알려드렸습니다.</p>

<p>이것을 간단하게 코드로 표현하면 아래와 같습니다.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">product</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">ProductDto</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
   <span class="n">item</span> <span class="k">&lt;-</span> <span class="n">itemReposotory</span><span class="o">.</span><span class="n">findByid</span><span class="o">(</span><span class="n">itemId</span><span class="o">)</span>
   <span class="n">catalog</span> <span class="k">&lt;-</span> <span class="n">catalogRepository</span><span class="o">.</span><span class="n">findById</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">catalogId</span><span class="o">)</span>
   <span class="n">brand</span> <span class="k">&lt;-</span> <span class="n">brandRepository</span><span class="o">.</span><span class="n">findById</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">brandId</span><span class="o">)</span>
   <span class="n">wishCount</span> <span class="k">&lt;-</span> <span class="n">itemWishCountRepository</span><span class="o">.</span><span class="n">findByItemId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
   <span class="n">category</span> <span class="k">&lt;-</span> <span class="n">categoryRepository</span><span class="o">.</span><span class="n">findOneByBrandId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">brandId</span><span class="o">)</span>
   <span class="n">detail</span> <span class="k">&lt;-</span> <span class="n">itemDetailRepository</span><span class="o">.</span><span class="n">findByItemId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
   <span class="n">certifications</span> <span class="k">&lt;-</span> <span class="n">itemCertificationRepository</span><span class="o">.</span><span class="n">findByItemId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="nc">ProductFactory</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">item</span><span class="o">,</span> <span class="n">brand</span><span class="o">,</span> <span class="n">catalog</span><span class="o">,</span> <span class="n">wishCount</span><span class="o">,</span> <span class="n">category</span><span class="o">,</span> <span class="n">detail</span><span class="o">,</span> <span class="n">certifications</span><span class="o">)</span>
</code></pre></div></div>

<p>위의 <a href="http://docs.scala-lang.org/tutorials/FAQ/yield.html#translating-for-comprehensions">for comprehension 코드는 flatMap과 map으로 변경</a>이 됩니다.
아래와 같은 룰을 통해 변환 하게 됩니다.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">c1</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">c2</span><span class="o">;</span> <span class="n">z</span> <span class="k">&lt;-</span> <span class="n">c3</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{...}</span>
</code></pre></div></div>

<p>중간 <code class="highlighter-rouge">&lt;-</code> 는 flatMap으로 마지막 <code class="highlighter-rouge">&lt;-</code> 는 map 함수를 이용해 아래 코드로 변하게 됩니다.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c1</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">c2</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="n">c3</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">z</span> <span class="k">=&gt;</span> <span class="o">{...})))</span>
</code></pre></div></div>

<p>Future의 flatMap은 앞의 행위가 완료 되었을때, 특정 API를 호출 했다면 그 API가 완료 되어야만 다음 API가 callback으로 수행하기 됩니다.</p>

<p><img src="http://i.imgur.com/AQt1rOb.png" alt="Future의 flatMap을 이용한 순차 합성" /></p>
<ul>
  <li>이미지 출처 : <a href="https://www.artima.com/shop/akka_concurrency">Akka Concurrency - 12. Coding in the Future</a></li>
</ul>

<p>그렇기 때문에 이 코드는 아래 순서대로 데이터를 가져오게 됩니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">item</span> <span class="k">=&gt;</span> <span class="n">catalog</span> <span class="k">=&gt;</span> <span class="n">brand</span> <span class="k">=&gt;</span> <span class="n">wishCount</span> <span class="k">=&gt;</span> <span class="n">category</span> <span class="k">=&gt;</span> <span class="n">detail</span> <span class="k">=&gt;</span> <span class="n">certification</span>
</code></pre></div></div>

<p><strong>flatMap</strong> 의 아용한 비동기 프로그램은 되지만 병렬 프로그램은 아닙니다.</p>

<p><a href="https://alexn.org/blog/2017/01/30/asynchronous-programming-scala.html#h4"><strong>async != parallel</strong></a> 입니다. 비동기가 된다고 병렬 프로그래밍은 아닙니다.</p>

<h2 id="병렬-프로그래밍">병렬 프로그래밍</h2>
<p><img src="http://i.imgur.com/45HkUaG.png" alt="" /></p>
<ul>
  <li>이미지 출처 : Reactive Microservices Architecture By Jonas Bonér, Co-Founder &amp; CTO Lightbend, Inc.</li>
</ul>

<p>서로 의존성이 없은 데이터라면 순차적으로 가져올 필요가 없습니다.</p>

<p>동시에, 병렬로 가져오면 됩니다.</p>

<p>병렬 프로그래밍은 간단한 수식을 통해 성능을 예측할수 있습니다.
특정 테스크를 실행하기 위해서 <strong>순차</strong>적으로 실행되야 하는 부분과 <strong>병렬</strong>로 실행 될수 있는 부분은 구분함으로서 가능합니다.</p>

<h3 id="speed-up-in-latency---amdahls-law">Speed up in latency - Amdahl’s law</h3>

<p>전체 테스크 중에 병렬로 처리 가능한 부분의 비율이 성능의 향상을 결정짓습니다.
병렬 프로그래밍, map-reduce와 같은 내용에 자주 나오는 <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl의 법칙</a>에 맞추어 보면</p>

<blockquote>
  <p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4ddfe7ea1f14ac8da03a6eda65459d1f8d85f6b9" alt="latency" /></p>

  <p>여기서 <strong>S(latency)</strong> 는 전체 테스크 실행의 이론적인 속도 향상이다.</p>

  <p><strong>s</strong> 는 병렬로 처리가능했을때 성능이 일어날수 있는 부분이다.</p>

  <p><strong>p</strong> 는 전체 테스크중에 성능 개선(병렬처리)이 가능한 부분의 원래 시간이다.</p>
</blockquote>

<p>각각의 데이터를 가져오는걸을 1초라 하면 각각의 연산의 단순합으 <code class="highlighter-rouge">1초 * 7 = 7초</code>가 걸리게 됩니다.
이중 병렬로 가져올수 있는것이 <strong>6초</strong>입니다.</p>

<p>먼저 동시에 2개씩 병렬로 처리하는 경우에는 그 성능이</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">slatency</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Float</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span>  <span class="mi">1</span> <span class="o">/</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="o">)</span> <span class="o">+</span> <span class="n">p</span> <span class="o">/</span> <span class="n">s</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="mi">6</span> <span class="o">/</span> <span class="mf">7.0</span>
<span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="mi">2</span>
<span class="n">slatency</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
<span class="c1">// 1.75
</span></code></pre></div></div>
<p><strong>1.75배</strong>가 증가합니다.
7초가 걸리던 응답 속도는 약 4초로 줄어들게 됩니다.</p>

<p>6개를 동시에 병렬로 처리가 가능하다면</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="mi">6</span> <span class="o">/</span> <span class="mf">7.0</span>
<span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="mi">6</span> <span class="c1">// 6 개를 동시에 실행하면
</span><span class="n">slatency</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
<span class="c1">// 3.49999
</span></code></pre></div></div>

<p>이번엔 기존 속도에 약 <strong>3.5배</strong> 정도 증가하게 됩니다.
예상 되는 응답시간은 7초에서 2초로 줄어들게 됩니다.
이는 기존에 monolithic 아키텍처와 같은 수준을 유지 할수가 있습니다.</p>

<p>물론 방금 말한 수치는 단순한 가정입니다.
복잡한 엔터프라이즈 환경에서 성능의 변수는 다양하고 많기 때문에 꼭 이렇다 말할수는 없습니다.
하지만 동시에 실행할 수 있다면 순차 프로그래밍보다 병렬 프로그래밍을 통해서 응답속도를 획기적으로 줄일 수 있습니다.</p>

<h3 id="scala-future의-eager-evaluation-활용하기">Scala Future의 Eager evaluation 활용하기</h3>
<p><code class="highlighter-rouge">scala.concurrent.Future</code>의 특성을 고려해서 구현해보겠습니다.
scala에서 기본으로 제공해주는 <a href="https://books.google.co.kr/books?id=iwZwDQAAQBAJ&amp;pg=PA209&amp;lpg=PA209&amp;dq=scala+future+eager+evaluation&amp;source=bl&amp;ots=lD1c5760xv&amp;sig=XXIuTBDKiLZkXvdZHrolaEFyLvk&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjKm5bRz-jVAhUKgrwKHfx9DUcQ6AEISzAG#v=onepage&amp;q=scala%20future%20eager%20evaluation&amp;f=false">Future</a>는 <a href="https://ko.wikipedia.org/wiki/%EC%A1%B0%EA%B8%89%ED%95%9C_%EA%B3%84%EC%82%B0%EB%B2%95">eager evaluation</a> 방식으로 동작합니다.
<a href="https://ko.wikipedia.org/wiki/%EB%8A%90%EA%B8%8B%ED%95%9C_%EA%B3%84%EC%82%B0%EB%B2%95">lazy(사용하는 시점) evaluation</a>이 아니라 선언되는 시점에 바로 동작하기 합니다.
간단하게 테스트 해보면 변수 <code class="highlighter-rouge">future</code>를 따로 실행을 하지 않아도 1초 후에 ‘hello world’가 화면에 출력됩니다.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>
<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span>
  <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"hello world"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 선언만 했는데 1초후 출력됨
</span><span class="n">hello</span> <span class="n">world</span>
</code></pre></div></div>

<p>Eager evaluation 특성을 이용해서 먼저 future를 실행하고 나중에 for comprehension으로 조합하는 코드를 만들수 있습니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">def</span> <span class="n">getProduct</span><span class="o">(</span><span class="n">itemId</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">ProductDto</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">itemFuture</span> <span class="k">=</span> <span class="n">itemRepository</span><span class="o">.</span><span class="n">findById</span><span class="o">(</span><span class="n">itemId</span><span class="o">)</span>
  <span class="n">itemFuture</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">item</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">catalogFuture</span> <span class="k">=</span> <span class="n">catalogRepository</span><span class="o">.</span><span class="n">findById</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">catalogId</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">brandFuture</span> <span class="k">=</span>  <span class="n">brandRepository</span><span class="o">.</span><span class="n">findById</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">brandId</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">wishFuture</span> <span class="k">=</span> <span class="n">itemWishCountRepository</span><span class="o">.</span><span class="n">findByItemId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">categoryFuture</span> <span class="k">=</span> <span class="n">categoryRepository</span><span class="o">.</span><span class="n">findOneByBrandId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">brandId</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">itemDetailFuture</span> <span class="k">=</span> <span class="n">itemDetailRepository</span><span class="o">.</span><span class="n">findByItemId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">itemCertificationFuture</span> <span class="k">=</span> <span class="n">itemCertificationRepository</span><span class="o">.</span><span class="n">findByItemId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">catalog</span> <span class="k">&lt;-</span> <span class="n">catalogFuture</span>
      <span class="n">brand</span> <span class="k">&lt;-</span> <span class="n">brandFuture</span>
      <span class="n">wishCount</span> <span class="k">&lt;-</span> <span class="n">wishFuture</span>
      <span class="n">category</span> <span class="k">&lt;-</span> <span class="n">categoryFuture</span>
      <span class="n">detail</span> <span class="k">&lt;-</span> <span class="n">itemDetailFuture</span>
      <span class="n">certifications</span> <span class="k">&lt;-</span> <span class="n">itemCertificationFuture</span>
    <span class="o">}</span> <span class="k">yield</span>
        <span class="nc">ProductFactory</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="n">item</span><span class="o">,</span> <span class="n">brand</span><span class="o">,</span> <span class="n">catalog</span><span class="o">,</span> <span class="n">wishCount</span><span class="o">,</span> <span class="n">category</span><span class="o">,</span> <span class="n">detail</span><span class="o">,</span> <span class="n">certifications</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이제 위의 코드는 병렬도 동작합니다.
<img src="http://i.imgur.com/OQQeSA1.png" alt="Eager evaluation과 flatMap" /></p>
<ul>
  <li>이미지 출처 : <a href="https://www.artima.com/shop/akka_concurrency">Akka Concurrency - 12. Coding in the Future</a></li>
</ul>

<p>하지만 코드가 2배로 늘어났다 한번만 쓰고 필요없는 local variable이 왕창 늘어 났습니다.
그리고 중대한 문제점이 하나 더 들어있습니다.
자바에도 Future에 대한 다양한 구현체, <a href="https://github.com/AsyncHttpClient/async-http-client/blob/master/client/src/main/java/org/asynchttpclient/ListenableFuture.java">thrird party 라이브러리</a>가 존재를 하듯이
이와 마찬가지로 스칼라에도 <a href="https://monix.io/docs/2x/eval/task.html">monix - Task</a>, <a href="https://github.com/scalaz/scalaz/blob/scalaz-seven/concurrent/src/main/scala/scalaz/concurrent/Task.scala">scalaz - Task</a>, <a href="https://github.com/twitter/util#futures">twitter future</a>등 다양한 비동기 구현체가 존재합니다.</p>

<p>이 구현체들은 <a href="https://docs.scala-lang.org/overviews/core/futures.html">scala.concurrent.Future</a> 처럼 eager evaluation을 한다는 보장은 없습니다.
<a href="https://github.com/twitter/util#futures">Twitter가 만든 Future</a> 구현체의 경우 eager evaluation을 하지만
monix와 scalaz의 Task는 <a href="https://blog.scalac.io/2017/06/01/why-should-you-care-about-monix.html">lazy evaluation</a>을 합니다.</p>

<h4 id="lazy-evaluation의-함정">Lazy evaluation의 함정</h4>

<p>같은 로직을 <code class="highlighter-rouge">monix.task</code>를 활용해서 구현할수 있습니다.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// scala future를 활용한 비동기 프로그램
</span><span class="k">object</span> <span class="nc">itemRepositoryScalaFuture</span> <span class="k">extends</span> <span class="nc">ItemRepository</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">findById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span>
    <span class="c1">// slow computation
</span>  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// monix task를 활용한 비동기 프로그램
</span><span class="k">object</span> <span class="nc">itemRepositoryMonixTask</span> <span class="k">extends</span> <span class="nc">ItemRepository</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">findById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
    <span class="c1">// slow computation
</span>  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>아래 수치는 같은 로직을 scala future와 monix task를 활용하여 수치를 비교한것입니다.
테스트에 대한 전체 소스코드는 <a href="https://github.com/ikhoon/scala-note/blob/master/scala-exercise/src/main/scala/exp/parallel.scala#L154">github</a>에 올려 놓았습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala future with eager evaluation
00:39:12 - item-10
00:39:13 - catalog-1000
00:39:13 - brand-100000
00:39:13 - wish-10
00:39:13 - category-100000
00:39:13 - detail-10
00:39:13 - certification-10
elapsed : 2.786119929 sec

monix task with lazy evaluation
00:39:14 - item-10
00:39:15 - catalog-1000
00:39:16 - brand-100000
00:39:17 - wish-10
00:39:18 - category-100000
00:39:19 - detail-10
00:39:20 - certificatTaskn-10
elapsed : 7.074971322 sec
</code></pre></div></div>

<p>우리의 코드는 더이상 병렬로 동작하지 않습니다. monix task는 7초 걸리고 scala future는 2.7초 걸렸습니다.
Eager evaluation의 효과를 이용해보려 했지만 여러개의 scala future를 합친결과는 monix의 task를 합친 결과는 다릅니다.</p>

<p>비동기 연산의 구현체가 바뀌었다고 병렬로 진행되것이 순차로 진행되는것을 누구도 원하지 않을 것입니다.
이를 해결하고 명확하게 프로그램에게 나는 이걸 병렬도 돌리고 싶다고 말할 수 있는 방법이 있습니다.</p>

<p>병렬 프로그래밍을 하기 위해서 <code class="highlighter-rouge">Monad</code>와 eager evaluation 활용해서 만드는것 보다
<code class="highlighter-rouge">Monad</code>의 친구 또다른 typeclass인 <code class="highlighter-rouge">Applicative</code>를 활용하는 방법이 있습니다.</p>

<h3 id="applicative-이건-뭔소리인가">Applicative 이건 뭔소리인가?</h3>

<p>Applicative 단어를 듣는 순간 이건 무엇인가 당황할수 있습니다.
Monad도 잘 모르는데 뭔 Applicative인가?</p>

<p><img src="http://jjalbox.com/_data/jjalboxthumb/2015/03/92_1846.jpg" style="width: 200px;" /></p>

<p>하지만 포기하지 마세요! 어렵지 않습니다. 다만 용어가 아직 익숙하지 않을 뿐입니다!</p>

<p>Applicative는 겨우, 단지, 고작 함수 2개로 정의 됩니다.</p>

<p>먼저 Applicative의 인터페이스 정의를 살며보면</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">ff</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>생각보다 복잡하진 않습니다. 단순히 pure와 ap함수로 구성되어 있습니다.</p>

<p>Applicative의 ap함수는 형태는 Functor의 map 모양과 유사합니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>ap함수의 map에서 받는 함수의 모양 <code class="highlighter-rouge">A =&gt; B</code>의 형태가 F로 감싼 <code class="highlighter-rouge">F[A =&gt; B]</code>로 감싸졌습니다. 이게 끝입니다.</p>

<p>그리고 주된 특징은 아래 그림에서 처럼 두개의 container를 열어서 함수를 적용하고 닫는것입니다.
<img src="https://vmayakumar.files.wordpress.com/2017/01/applicatives.png" alt="그림으로 설명하는 Applicative" /></p>
<ul>
  <li>이미지 출처 : <a href="https://vmayakumar.wordpress.com/2017/01/17/functional-programing-in-javascript/">Functional programming in javascript</a></li>
</ul>

<p>두개를 연다는것은 두개를 <strong>동시에 열수(parallel)</strong>도 있다는 뜻입니다.</p>

<p>오픈소스 함수형 프로그래밍 라이브러리인 <a href="https://typelevel.org/cats/">cats</a>의 <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Applicative.scala#L16-L23">Applicative trait</a>와 <a href="https://github.com/typelevel/cats/blob/f4aa32d803d99d981ba46b637832c79a97665148/core/src/main/scala/cats/Apply.scala#L17">Apply trait</a>를 통해서 ap함수와 pure함수를 확인할수 있습니다.</p>

<h4 id="다양한-함수를-이용한-상태-변경">다양한 함수를 이용한 상태 변경</h4>
<p>함수형 언어에서 에서 <code class="highlighter-rouge">F[A]</code>를 <code class="highlighter-rouge">F[B]</code>로 바꾸는 여러가지 방법이 있습니다.
잠깐 정리하고 넘어가보겠습니다.</p>
<ul>
  <li><a href="https://tpolecat.github.io/2014/03/21/functor.html">Functor</a> : <code class="highlighter-rouge">A =&gt; B</code> 함수를 받아 <code class="highlighter-rouge">F[A]</code> 를 <code class="highlighter-rouge">F[B]</code>로 변형시키는 <code class="highlighter-rouge">map</code> 함수를 가지고 있습니다.
    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="o">=&gt;</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div>    </div>
  </li>
  <li>Monad : <code class="highlighter-rouge">A =&gt; F[B]</code> 함수를 받아 <code class="highlighter-rouge">F[A]</code>를 <code class="highlighter-rouge">F[B]</code>로 변형시키는 <code class="highlighter-rouge">flatMap</code> 함수를 가지고 있습니다.
    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flatMap</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="o">=&gt;</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div>    </div>
  </li>
  <li>Applicative : <code class="highlighter-rouge">F[A =&gt; B]</code> 함수를 받아 <code class="highlighter-rouge">F[A]</code>를 <code class="highlighter-rouge">F[B]</code>로 변형시키는 <code class="highlighter-rouge">ap</code> 함수를 가지고 있습니다.
    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ap</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div>    </div>
  </li>
  <li><a href="https://typelevel.org/cats/api/cats/Comonad.html">Comonad</a> : <code class="highlighter-rouge">F[A] =&gt; B</code> 함수를 받아 <code class="highlighter-rouge">F[A]</code>를 <code class="highlighter-rouge">F[B]</code>로 변형시키는 <code class="highlighter-rouge">coflatMap</code> 함수를 가지고 있습니다.
    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">coflatMap</span><span class="k">:</span> <span class="o">(</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div>    </div>
    <p>그외에도 F[A]를 F[B]를 변화 시키는 <a href="https://typeclassopedia.bitbucket.io/#slide-14">여러 typeclass</a>가 존재합니다. 또한 <a href="http://eed3si9n.com/learning-scalaz/Natural-Transformation.html"><code class="highlighter-rouge">F[A] ~&gt; G[A]</code></a>로 변환 시키는 것도 존재합니다.
이 글에서는 Applicative에만 집중하겠습니다.</p>
  </li>
</ul>

<p>언제나 그렇듯 의문이 들고 많은 질문을 받는습니다.
Applicative란 함수는 도대체 언제 사용해야하는가?
Applicative란 개념이 왜 필요한가?</p>

<p>Applicative 안에 있는 ap 함수는 future를 활용한 병렬 프로그래밍을 할때 효과적으로 사용될수 있습니다.
ap함수는 바로 사용하는 경우는 많이 없지만 활용한 보조함수 <code class="highlighter-rouge">product</code>, <code class="highlighter-rouge">mapN</code> 같은 함수를 많이 사용하게 됩니다.</p>

<h3 id="future-병렬-처리-예를-통한-applicative-이해하기">Future 병렬 처리 예를 통한 Applicative 이해하기</h3>
<p>Future의 기준으로 ap 함수를 생각해보겠습니다.</p>

<p>두개의 future fa, fb가 있고 두개의 future안에 들어 있는 값을 동시에 완료되는 연산하고 싶다고 하고 싶다면</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fa</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="n">a</span> <span class="o">}</span>
<span class="k">def</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="n">b</span> <span class="o">}</span>
<span class="c1">// 동시에 실행
</span><span class="k">val</span> <span class="n">fab</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// fa와 fb가 동시에 실행되고 그값이 fab에 저장된다.
</span></code></pre></div></div>

<p>이제 ap함수를 활용해서 <code class="highlighter-rouge">fab</code>를 도출해보겠습니다. 즉 fa와 fb의 값을 합쳐 보겠습니다.</p>

<p>ap함수는 두번째 인자가 함수를 감싼 <code class="highlighter-rouge">F[A =&gt; B]</code>입니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">ff</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>입력이 <code class="highlighter-rouge">F[A =&gt; B]</code>인데 우리가 가지고 있는 값은 <code class="highlighter-rouge">F[B]</code>입니다. 입력값의 타입을 맞추어 주기 위해 우리는 fb를 변환해야 합니다.
아래와 같이 바꿀수 있습니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">fa2b</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">fb</span><span class="o">)(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div></div>

<p>우리가 최종적으로 원하는건 A와 B값의 쌍이기 때문에
<code class="highlighter-rouge">Future[B]</code>의 B값에 A의 값이 들어오면 A와 B의 값의 쌍으로 변환 시키는 <code class="highlighter-rouge">faab: Future[A =&gt; (A, B)]</code>의 형태로 바꾸어 보겠습니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">faab</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">fb</span><span class="o">)(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
</code></pre></div></div>

<p>이제 하나가 함수가 되었기 때문에 ap함수에 적용시킬수 있습니다. 타입도 정확합니다.
<code class="highlighter-rouge">(F[A])(F[A =&gt; (A, B)]) =&gt; F[(A, B)]</code> 그다음에 <code class="highlighter-rouge">ap(fa)(faab)</code>를 적용시키면 <code class="highlighter-rouge">F[(A, B)]</code>의 형태가 됩니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">fab</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">ap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">faab</span><span class="o">)</span>
</code></pre></div></div>
<p>어떻게 사용할지 몰랐던 <strong>ap 함수는 두개의 Future를 합치는데 탁월한 역할</strong>을 합니다.</p>

<p>간단하게 두개의 future를 합치는 함수를 만들었습니다. 이를 일반화하고 이 함수 이름을 product라 하겠습니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">product</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">faab</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">fb</span><span class="o">)(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
  <span class="k">val</span> <span class="n">fab</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">ap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">faab</span><span class="o">)</span>
  <span class="n">fab</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 product를 활용하면 간단하게 두개의 future를 병렬 연산하고 그 완료된 값을 합쳐 보겠습니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fa</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="n">a</span> <span class="o">}</span>
<span class="k">def</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="n">b</span> <span class="o">}</span>
<span class="c1">// 동시에 실행
</span><span class="k">val</span> <span class="n">fab</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">product</span><span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">fb</span><span class="o">)</span>
</code></pre></div></div>

<p>아직 우리는 ap 구현하지 않았습니다. ap 인터페이스를 정의만 하고 이를 이용해서 product함수를 만드는것만 구현했습니다.</p>

<p>ap를 두개의 future를 동시에 완료되게 구현하면 동시에 fa, fb가 실행되고 <code class="highlighter-rouge">Future[(A, B)]</code>를 만들수 있습니다 .
즉 병렬로 A와 B를 가져오는 연산을 ap함수에 구현하면 product함수도 병렬로 실행되게 됩니다.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">fab</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span> <span class="k">=</span>
  <span class="n">fab</span> <span class="n">zip</span> <span class="n">fa</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">fa</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>

<p>실제 많이 사용되는 오픈소스 라이브러리도 이와 같은 방식을 이용해서 구현하였습니다.</p>

<p>스칼라의 함수형 프로그래밍을 도와주는 <a href="https://github.com/scalaz/scalaz/blob/02f50d88fa9f8e8f83b99d33a3216b56137872f8/core/src/main/scala/scalaz/std/Future.scala#L55-L57">scalaz의 future instance</a>, free monad를 쉽게 사용할수 있게 도와주는 <a href="http://frees.io/">freestyle</a>에 구현되어 있는 <a href="https://github.com/frees-io/freestyle/blob/24456d92b30209ff9cb1fa5f309601accfc2ca99/modules/core/shared/src/main/scala/freestyle/NonDeterminism.scala#L40-L41">future instance</a>는 <a href="http://immutables.pl/2016/10/08/parallel-futures-and-exceptions/">future의 zip</a> 연산을 활용해서 동시성을 구현하였습니다.</p>

<p>하지만 cats의 <a href="https://github.com/typelevel/cats/blob/f4aa32d803d99d981ba46b637832c79a97665148/core/src/main/scala/cats/instances/future.scala#L11">future instance는 별도의 구현없이 flatMap을 이용</a>하여 구현하였습니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// cats/FlatMap.scala
// https://github.com/typelevel/cats/blob/f4aa32d803d99d981ba46b637832c79a97665148/core/src/main/scala/cats/FlatMap.scala#L96-L97
</span><span class="k">override</span> <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ff</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">flatMap</span><span class="o">(</span><span class="n">ff</span><span class="o">)(</span><span class="n">f</span> <span class="k">=&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">))</span>
</code></pre></div></div>
<p>flatMap을 이용해서 ap를 구현할수는 있습니다.
하지만 이 ap함수는 flatMap의 순차 연산 특성을 가지게 되기 때문에
병렬연산의 특성을 가지 있지 않다는것에 주의해야합니다.</p>

<p>앞에서 말했듯이 cats의 future instance가 실제 병렬로 잘 동작하는 이유는 scala의 future가 eager evaluation이기 때문입니다.
product 함수를 호출하는 시점에 이미 두개의 future가 이미 실행되었기 때문입니다.</p>

<p>cats에서 기본 제공해주는 future instance를 사용하지 않고 별도로 future.zip을 이용해서 구현해서 사용하는 사례 <a href="http://immutables.pl/2016/10/08/parallel-futures-and-exceptions/">1</a>, <a href="https://github.com/frees-io/freestyle/blob/e42109a5416d95e221d0924710c5ff3e386edd75/freestyle/shared/src/main/scala/freestyle/NonDeterminism.scala#L41">2</a>가 있습니다.</p>

<p>그리고 <a href="https://github.com/scalaz/scalaz">scalaz</a>와 <a href="https://monix.io/">monix</a>에서는 <a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm">nondeterminism</a>이라는 기능을 제공해서 Applicative를 병렬로 연산하거나 순차연산 할것인지를 명시적으로 선택할수 있습니다.</p>

<h4 id="nondeteminism을-이용한-병렬-프로그래밍">Nondeteminism을 이용한 병렬 프로그래밍</h4>
<p>scalaz의 task는 아래 예를 참고하면 됩니다.
parallel로 동작하기 위해서는 <code class="highlighter-rouge">Nondeterminism</code>를 활용하면 됩니다.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz._</span><span class="o">,</span> <span class="nc">Scalaz</span><span class="o">.</span><span class="k">_</span>
<span class="c1">// sequence
</span><span class="k">def</span> <span class="n">runAp</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">ap2</span> <span class="k">=</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">Task</span><span class="o">].</span><span class="n">apply2</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
  <span class="n">ap2</span><span class="o">.</span><span class="n">unsafePerformSync</span>
<span class="o">}</span>

<span class="c1">// parallel
</span><span class="k">def</span> <span class="n">runNondeterminism</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">both</span> <span class="k">=</span> <span class="nc">Nondeterminism</span><span class="o">[</span><span class="kt">Task</span><span class="o">].</span><span class="n">mapBoth</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
  <span class="n">both</span><span class="o">.</span><span class="n">unsafePerformSync</span>
<span class="o">}</span>
</code></pre></div></div>

<p>monix의 task 경우에도 아래 코드처럼 nondeterminism을 이용하면 applicative에서 병렬 프로그래밍이 가능합니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="c1">// parallel
</span><span class="k">def</span> <span class="n">runWithZip</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">tc</span> <span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">ta</span><span class="o">.</span><span class="n">zipMap</span><span class="o">(</span><span class="n">tb</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// sequence
</span><span class="k">def</span> <span class="n">runWithAp</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">tc</span> <span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">Task</span><span class="o">].</span><span class="n">map2</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// parallel
</span><span class="k">def</span> <span class="n">runWithNondeterminismAp</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">monix.eval.Task.nondeterminism</span>
  <span class="k">val</span> <span class="n">tc</span> <span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">Task</span><span class="o">].</span><span class="n">map2</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위의 코드의 <a href="https://github.com/ikhoon/scala-note/blob/8ab53e586a6352614ab305b60d01988e79a5a633/scala-exercise/src/main/scala/exp/nondeterminism.scala#L47-L121">전체 코드는 github</a>에 올려놓았습니다.</p>

<p>이제 이를 활용하여 원래 처음 만들었던 프로그램에 적용을 하면 Applicative의 <code class="highlighter-rouge">mapN</code> 연산자를 활용하여서 병렬 연산을 하고 빠른 응답을 얻을수 있습니다.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">itemRepository</span><span class="o">.</span><span class="n">findById</span><span class="o">(</span><span class="n">itemId</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">item</span> <span class="k">=&gt;</span>
  <span class="o">(</span>
    <span class="n">catalogRepository</span><span class="o">.</span><span class="n">findById</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">catalogId</span><span class="o">),</span>
    <span class="n">brandRepository</span><span class="o">.</span><span class="n">findById</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">brandId</span><span class="o">),</span>
    <span class="n">itemWishCountRepository</span><span class="o">.</span><span class="n">findByItemId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="o">),</span>
    <span class="n">categoryRepository</span><span class="o">.</span><span class="n">findOneByBrandId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">brandId</span><span class="o">),</span>
    <span class="n">itemDetailRepository</span><span class="o">.</span><span class="n">findByItemId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="o">),</span>
    <span class="n">itemCertificationRepository</span><span class="o">.</span><span class="n">findByItemId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
  <span class="o">).</span><span class="n">mapN</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">catalog</span><span class="o">,</span> <span class="n">brand</span><span class="o">,</span> <span class="n">wish</span><span class="o">,</span> <span class="n">category</span><span class="o">,</span> <span class="n">detail</span><span class="o">,</span> <span class="n">cert</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">List</span><span class="o">(</span><span class="n">brand</span><span class="o">,</span> <span class="n">catalog</span><span class="o">,</span> <span class="n">wish</span><span class="o">,</span> <span class="n">category</span><span class="o">,</span> <span class="n">detail</span><span class="o">,</span> <span class="n">cert</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>함수형 언어에는 다양한 특징이 있는데 이 특징들은 마이크로 서비스를 하기에 좋은 언어라고 생각합니다.
특히 비동기 프로그래밍(Monad), 병렬프로그래밍(Applicative)에는 장점이 부각이 됩니다.</p>

<p>꼭 함수형 언어가 아니더라도 마이크로 서비스를 적용하고 있거나 적용하려고 한다면 코드의 많은 부분을 병렬 프로그래밍으로 바꿀수 있는지 보고 적극적으로 병렬로 처리하면
더욱더 빠른 응답을 주고 마이크로 서비스의 장점을 최대화 할 수 있을 것이라 생각합니다. :-)</p>

</div>
  <div id="post-footer">
    
    <a id="post-author" href="/authors/liam.m/">
      <div id="author-image" style="background-image:url(/files/authors/liam.m.jpg);">
        <span class="sr-only">liam.m's profile image</span>
      </div>
      <p id="author-name">liam.m</p>
    </a>
    <p id="post-date">2017-09-02 12:57</p>
    <a id="post-more" href="/authors/liam.m/">
      <span>Read more posts by this author</span>
    </a>
  </div>
</div>

<div class="container" style="margin-top:25px; padding:0px">
  <a href="https://www.welcomekakao.com" target="_blank"><img src="/files/career2020.jpg" style="width:100%;"></a>
</div>

<div id="post-links" class="container">
  
  
  <div id="post-prev" style="background-image: url(/files/covers/employment_cover.png);" >
    <div>
      <h3><a href="/2017/08/30/employment/">카카오 블라인드 신입 개발자 공채를 실시합니다!</a></h3>
      <p>YOU MIGHT ENJOY</p>
    </div>
  </div>
  
  
  
  <div id="post-next" style="background-image: url(/files/covers/code-festival.jpg);" >
    <div>
      <h3><a href="/2017/09/14/code-festival-round-2/">카카오 코드 페스티벌 본선 이야기</a></h3>
      <p>NEXT POST</p>
    </div>
  </div>
  
</div>

<div id="lightbox">
  <div id="lightbox-image"></div>
</div>

    <div class="clearfix"></div>

    <a href="#" id="back-to-top"></a>
</div>

<div id="footer" class="container-fluid">
    <ul id="links">
        
        <li>
            <a id="link-github" href="http://github.com/kakao" target="_blank">
                <span class="sr-only">github</span>
            </a>
        </li>
        
        
        <li>
            <a id="link-facebook" href="http://facebook.com/nkakao" target="_blank">
                <span class="sr-only">facebook</span>
            </a>
        </li>
        
        
        <li>
            <a id="link-twitter" href="http://twitter.com/kakaodev" target="_blank">
                <span class="sr-only">twitter</span>
            </a>
        </li>
        
        <li>
            <a id="link-rss" href="/rss" target="_blank">
                <span class="sr-only">rss</span>
            </a>
        </li>
    </ul>
    <ul id="footer-menu">
        <li><a href="//www.kakaocorp.com">Kakao</a></li>
        <li><a href="//careers.kakao.com/jobs">Jobs</a></li>
        <li><a href="//privacy.kakaocorp.com">Privacy</a></li>
    </ul>
    <p id="copyright">
        <a href="//www.kakaocorp.com">Copyright &copy; Kakao Corp.</a>
        All rights reserved.
    </p>
</div><!--#footer-->


<script src="/assets/lib/jquery-1.12.0.min.js"></script>
<script src="/assets/lib/jquery.magnific-popup.min.js"></script>
<script src="/assets/js/index.js"></script>
<script src="//developers.kakao.com/sdk/js/kakao.min.js"></script>


<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date();
        a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-72007721-1', 'auto');
    ga('send', 'pageview');
</script>




    <script type='text/javascript'>
   //<![CDATA[
    // 사용할 앱의 JavaScript 키를 설정해 주세요.
    //Kakao.init('65d48e116d8b9409e08960c4800c3017');
    function shareStory(abs_page_url) {
        Kakao.Story.share({
            url: abs_page_url,
            text: '카카오 기술블로그 #개발자 #카카오'
        });
    }
    //]]>
</script>

    
    <script>
window.fbAsyncInit = function() {
  FB.init({
    appId      : '1204347326263800',
    xfbml      : true,
    version    : 'v2.7'
  });
};

(function(d, s, id){
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script>

    

    
    <script>!function (d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location) ? 'http' : 'https';
        if (!d.getElementById(id)) {
            js = d.createElement(s);
            js.id = id;
            js.src = p + '://platform.twitter.com/widgets.js';
            fjs.parentNode.insertBefore(js, fjs);
        }
    }(document, 'script', 'twitter-wjs');
</script>

    

    
    <script src="https://apis.google.com/js/platform.js" async defer>
    {
        lang: 'ko'
    }
</script>

    

</body>
</html>
