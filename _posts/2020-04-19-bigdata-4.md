---
title: "instructions of Linux-Understading BigData(4)"
categories: 
  - BigData
last_modified_at: 2020-04-25T19:18:00+09:00
toc: true
---

Intro
---
학교 수강과목에서 학습한 내용을 복습하는 용도의 포스트입니다.<br/>
빅데이터 개념과 오픈소스인 아파치 하둡과 맵리듀스 및 스파크를 이용한 빅데이터 적용을 공부합니다.<br/>
맵 리듀스의 경우 사용하기에 다소 진입장벽이 있는편입니다.<br/> 스파크처럼 통합 환경을 제공하지 않아 원하는 유틸리티나 라이브러리를 별도로 연결해서 사용해야하기 때문입니다. 이를 해소하는 것이 스파크라는 분산 데이터 처리 통합 엔진입니다.<br/>
따라서 맵 리듀스로 먼저 공부해보고, 스파크로 넘어갑니다.<br/>

스파크 엔진의 경우 Java가 아닌 Scalar라는 언어로 사용하며, 기존 우리가 알고 있는 SQL을 통해 고급 질의가 가능하며, 시각화나 스트림 처리 및 기계학습등 까지의 높은 수준의 분석을 제공하는 통합 프레임 워크입니다.<br/>

빅데이터 컴퓨팅(분산시스템상의 분산처리 환경)의 기본 개념과 원리를 이해하고 이를 실습해보는 과정에서 2대 이상의 리눅스 클러스터 서버를 구축 및 활용할 것입니다.<br/>

[빅데이터이해(1) 보러가기](https://ohjinjin.github.io/bigdata/bigdata-1/)<br/>
[빅데이터이해(2) 보러가기](https://ohjinjin.github.io/bigdata/bigdata-2/)<br/>
[빅데이터이해(3) 보러가기](https://ohjinjin.github.io/bigdata/bigdata-3/)<br/>


이번엔 리눅스 클러스터 상에서 하둡과 스파크가 동작하기 때문에 리눅스의 파일에 관련된 명령 및 기본 명령어를 정리하겠습니다.<br/>

아래 순서로 학습이 진행됩니다.<br/>
1. 파일 작업 명령어
2. 기본 관리 명령어
3. 사용자 관리

파일 작업 명령어
----
리눅스의 파일과 디렉토리는 계층적인 트리구조로 이루어져있습니다.<br/>
최상위는 항상 root 디렉토리에 기반을 합니다.<br/>
사용자가 로그인을 하면 처음 위치하는 디렉토리는 홈입니다.<br/>
"~"로 홈을 대신 부르기도 합니다.<br/>
기본적으로 "/home/userID" 형식으로 생겼습니다.<br/>
사용자의 홈 디렉토리를 식별하는 $HOME이라는 환경변수를 지정하게 되는데, 이러한 환경변수들은 ".profile", ".login", bourne again shell record라는 즉, ".bashrc", ".cshrc" 등에 저장됩니다.<br/>
참고로 .으로 시작하는 파일은 숨겨진 파일입니다.<br/>
절대경로와 상대경로의 개념을 알아야합니다.<br/>

* 절대경로 : 모든 경로명을 반드시 루트 디렉토리인 "/"로 시작되어 특정한 파일이나 디렉토리를 표시<br/>
* 상대경로 : 현재 작업 디렉토리에 대해 상대적인 경로이름 이용<br/>


{% raw %} <img src="https://ohjinjin.github.io/assets/images/20200418bigdata/capture48.JPG" alt=""> {% endraw %}

만약 우리가 root/export/home/bigdata에 위치해있다면 home 디렉토리는 ../으로 상대위치를 표시하며 usr로 가려면 ../../../usr/라고 상대위치를 표시할 수 있습니다.<br/>

1. ls<br/>
* 기능 : 파일 및 디렉토리의 목록을 출력합니다.<br/>
* 형식 : ls [옵션] [ {디렉토리 \| 파일} ]<br/>
* 옵션<br/>
\-l : 파일 크기, 저장날짜, 허가권(permission), 소유권 등을 포함해 자세히 보기<br/>
참고로 허가권에는 Read, Write, eXecution 등이 있습니다.<br/>
\-a : 마침표로 시작하는 숨겨진 파일을 포함한 모든 파일 보여주기<br/>
\-t : 시간 순서대로 정렬하여 보기<br/>
\-R : 하위 디렉토리의 파일까지 재귀적으로 보여주기<br/>
참고로 \-al 등 섞어 사용도 가능합니다.<br/>

2. cd<br/>
* 기능 : 디렉토리 이동<br/>
* 형식 : cd [디렉토리명]<br/>
* 디렉토리명<br/>
~ : 자신의 홈 디렉토리<br/>
~(계정이름) : 다른 사용자의 홈 디렉토리<br/>
. : 현재 디렉토리<br/>
.. : 상위 디렉토리<br/>
\- : 바로 직전에 사용한 디렉토리<br/>
* pwd는 현재 작업중인 디렉토리를 보여주는 명령어입니다.<br/>

3. cat<br/>
cf) 파일의 생성 및 보기 시에는 vi, emacs, nano, gedit(GUI) 등의 문서 편집기를 이용합니다.<br/>
cf) cat(catenate)은 파일을 새로 만들거나 덮어쓰거나 어펜드하는 것이 가능합니다.<br/>
보통 cat 명령을 이용할 때에는 **리다이렉션**이라는 기호를 함께 사용하곤 합니다.<br/>
cat \> test.dat 또는 cat \>\> test.dat 등이 그 예입니다. <br/>리다이렉션 없이 사용할 때에는 (ex)cat test.dat) 파일의 내용을 화면에 출력하는 기능을 합니다.<br/>

4. more<br/>
파일의 내용이 큰 경우에는 화면을 넘어가기 때문에 more 명령어를 이용하여 한번에 한 화면씩 내용을 보여주게됩니다.<br/>
다음 화면 전환시에는 스페이스바를 누르시면되고, 종료 시에는 q를 누릅니다.<br/>

5. head, tail<br/>
* head -n 파일 : 처음 n줄 보기<br/>
* tail -n 파일 : 마지막 n줄 보기<br/>
n의 default값은 10 입니다.<br/>

6. cp<br/>
* 기능 : 소스파일을 목적파일에 복사<br/>
* 형식 : cp [옵션] 소스파일 목적파일<br/>
* 옵션<br/>
\-f : 강제적 복사 목적파일이 이미 존재하더라도 확인을 요구하지 않습니다.<br/>
\-i : 대화형 복사로 사용자에게 확인을 한 번 더 받습니다.<br/>

7. mv<br/>
* 기능 : 파일을 이동하는 명령이며, 윈도우의 rename 명령에 해당합니다.<br/>
* 형식 : mv [소스파일] [목적파일] or mv [소스파일들 ...] [디렉토리]<br/>
후자의 형식대로 명령을 입력하게되면 소스파일들을 지정한 디렉토리로 이동합니다.<br/>
mv명령에도 \-f와 \-i 옵션이 있습니다.<br/>

8. mkdir, rmdir<br/>
* 기능 : 디렉토리를 생성합니다, 디렉토리를 삭제합니다.<br/>
* 형식 : mkdir [디렉토리명], rmdir [디렉토리명]<br/>

문제를 하나 내보겠습니다.<br/>
명령어 "mv test.\* .."를 입력하게되면 어떤 일이 일어날까요?<br/>
현재위치의 상위 디렉토리로 확장자 상관없이 test라는 이름을 가진 모든 파일이 이동되는 것 입니다. \*는 와일드카드입니다.<br/>

9. rm<br/>
* 기능 : 파일을 삭제합니다.<br/>
* 형식 : rm [옵션] 파일명<br/>
* 옵션<br/>
\-f : 강제 삭제<br/>
\-i : 대화형 삭제<br/>
\-r : 재귀적으로 실행, 파일을 삭제할 때 하위 디렉토리를 포함해 모든 파일을 삭제합니다.<br/>

문제를 하나 내겠습니다.<br/>
현재 위치의 모든 파일을 다 삭제하고자 할때는 어떤 명령어를 입력하면 될까요?<br/>
정답은 rm \-rf \*입니다.<br/>

10. ln<br/>
* 기능 : 원본파일을 가리키는 링크 파일을 생성<br/>
* 형식 : ln [옵션] 원본파일 링크파일<br/>
* 옵션<br/>
\-s : 심볼릭 링크로 설정하는 옵션<br/>
\-l : 링크파일에 어떤 링크가 있는지 확인하는 옵션<br/>

cf) 링크의 종류<br/>
* 하드링크 : 원래의 파일과 동일한 i\-node를 가리킵니다. <br/>i\-node는 메타데이터(파일의 속성) 등이 저장되는 곳 입니다. <br/>그렇기 때문에 원본 파일 이동 시에도 원본 파일에 접근이 가능합니다.<br/>
* 소프트링크 : symbolic link라고도 부르며, 새로운 i\-node가 생성되어 원본 파일과 연결됩니다. <br/>
다른 파티션 뿐 아니라 다른 네트워크 장치에 있는 파일에도 링크를 걸 수 있습니다. <br/>
하지만 원본파일이 이동되면 접근할 수 없습니다. <br/>
마치 윈도우의 바로가기 기능과 흡사합니다.<br/>

11. chmod<br/>
* 기능 : 파일 권한 변경하기<br/>
파일의 허가권은 파일타입, 소유자, 그룹, 기타사용자 총 네 개의 부분으로 나누어져 있습니다.<br/>
허가권을 표시할 때에는 읽기 권한인 R, 쓰기 권한인 W, 실행 권한인 X 순서대로 표시하게 되며 권한이 없는 경우에는 해당하는자리를 \-로 표시하게 됩니다.<br/>
아예 허가권이 없는 파일의 경우는 \-\-\-로 표시되겠죠?<br/>
허가권 자리별 의미를 아래 캡처에 정리해드리겠습니다.<br/>
{% raw %} <img src="https://ohjinjin.github.io/assets/images/20200418bigdata/capture46.JPG" alt=""> {% endraw %}
<br/>
위 예제의 경우 디렉토리가 아닌 파일이며, 소유자는 읽고 쓸수 있는 권한이있고 실행권한은 없으며, 그룹과 기타 사용자에게는 읽기 권한만 있는 파일이라는 것을 알 수 있습니다.<br/>
파일 허가권은 여러 조합이 나올 수 있겠죠?<br/>
관련하여 이미 잘 정리해두신 포스팅 링크를 [여기](http://byseob.blogspot.com/2010/08/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%86%8C%EC%9C%A0%EA%B6%8C%EA%B3%BC-%ED%97%88%EA%B0%80%EA%B6%8C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0.html) 에 걸어두겠습니다.<br/>
이러한 권한을 변경하기 위해서는 아래 형식의 명령어를 입력하게 됩니다.<br/>
> chmod [옵션] change ,{change}* {fileName}\+<br/>

문제를 하나 봅시다!<br/>
\-rw\-rw\-r\-\- 2 lee lee 21 3월 22 14:35 test.dat<br/>
이라는 파일을 아래처럼 바꾸려면 어떤 명령어를 입력하면 될까요?<br/>
\-rwxr\-\-\-\-\- 2 lee lee 21 3월 22 14:35 test.dat<br/>

정답은 chmod u\+x,g\-w,o\-r test.dat 입니다.<br/>

이 방법이 번거롭다면 8진수로 계산하여 권한을 설정할 수도 있습니다. <br/>
위 문제를 8진수로 변경한다면 정답은 chmod 740 test.dat 입니다.<br/>

12. find<br/>
* 기능 : 디렉토리 트리에서 파일을 찾고자 할 때 사용<br/>
* 형식 : find 탐색을시작할디렉토리 [옵션]<br/>

/etc 이하 디렉토리에서 "pass"로 시작하는 파일의 경로를 찾으려면 아래 명령어를 입력하시면 됩니다.<br/>
> find /etc \-name pass* \-print<br/>

/usr/src 이하 디렉토리에서 이름이 core인 모든 파일을 찾아 삭제하려면 아래 명령어를 입력하시면 됩니다.<br/>
> find /usr/src \-name core \-exec rm<br/>

13. locate<br/>
* 기능 : 파일이름으로 간단하게 파일을 찾는 명령<br/>
* 형식 : locate 파일명<br/>

14. which<br/>
* 기능 : 파일의 위치 보기<br/>
* 형식 : which 파일명<br/>
이 명령어는 찾고자하는 파일의 전체 경로(full path)를 알아볼 때 유용합니다.<br/>
which 명령어는 환경변수에 설정되어있는 실행 경로만을 검색하므로 find 명령어랑 차이가 있죠.<br/>

15. whereis<br/>
* 기능 : 명령어 위치보기<br/>
* 형식 : whereis 명령어 및 매뉴얼<br/>
환경변수에 등록되어있는 각종 경로를 검색하여 명령어 및 매뉴얼 위치를 검색합니다.<br/>

16. 리다이렉션<br/>
프로그램의 출력을 파일로 보내거나 입력하는 기능입니다.<br/>
overwrite는 \>, append는 \>\>, input은 <입니다.<br/>

17. grep<br/>
* 기능 : 지정된 파일에서 지정된 문자열을 읽어 해당 줄을 반환해주는 등의 기능<br/>
* 형식 : grep 문자열 파일명<br/>

18. 파이프<br/>
* 기능 : 한 명령의 실행결과가 \| 기호 다음의 명령으로 전달되는 기능입니다.<br/>
* 형식 : 앞선명령 \| 이후의명령<br/>

19. 세미콜론<br/>
* 기능 : 같은 라인에 여러개의 명령어를 한 번에 입력하는 용도<br/>
* 형식 : 첫번째 명령; 두번째 명령<br/>

20. 백그라운드<br/>
* 기능 : 명령의 종료를 기다리지 않고 바로 다음 명령을 기다리는 프롬트 상태<br/>
* 형식 : 명령 끝에 & 입력<br/>
이는 실행이 긴 프로세스나 명령에 유용하며, 참고로 &가 없는 일반 명령 실행은 포그라운드라고 합니다.<br/>

21. ps<br/>
* 기능 : 프로세스 상태 확인<br/>
* 형식 : ps [옵션]<br/>
* 옵션<br/>
\-e,A : 모든 프로세스<br/>
\-f : 절대경로 표시<br/>
\-l : 긴형식으로 표시<br/>
\-u : 실행 유저와 실행 시간 표시<br/>
\-j : 작업 제어 형식으로 표시<br/>
\-s : 시그널 형식으로 표시<br/>
\-m : 메모리 정보<br/>
\-a : 다른 사용자의 프로세스<br/>
\-x : 터미널 제어 없는 프로세스<br/>

22. kill<br/>
* 기능 : 프로세스 종료 시키기<br/>
* 형식 : kill [옵션] 프로세스id<br/>
* 옵션<br/>
\-s또는 \-number : 프로세스에 시그널 번호를 보냅니다.<br/>
\-9 : 프로세스를 강제로 종료시킵니다.<br/>
<br/><br/>

기본관리 명령어
---
1. sudo<br/>
리눅스는 아시다시피 멀티태스킹, 멀티유저 운영체제이기때문에 사용자모드와 커널모드(=관리자모드) 이중모드로 동작을 합니다.<br/>
엄격히 구분이 되어있는 이 두 모드에 대해 사용가능한 명령어가 따로 있습니다.<br/>
수퍼유저 권한 사용 방법은 크게 세 가지가 있습니다.<br/>
* root 계정으로 로그인<br/>
* su 명령을 사용하여 root 계정 권한 획득<br/>
* sudo 명령어를 사용하여 root 권한으로 명령어 실행<br/>
예제를 봅시다.<br/>
test.dat 파일의 사용자 소유권 변경을 하려면 어떤 명령어를 입력하면 될까요?<br/>
> chown username filename<br/>

위 명령어를 통해 파일 filename의 소유권을 사용자 username으로 지정합니다.<br/>
하지만 관리자가 아니기 때문에 이 명령어를 입력했을 때 오류가 납니다.<br/>
일시적 관리자 권한을 가져다 쓸 수 있는 **sudo**라는 명령어를 이용하여 다시 명령을 하면 해결할 수 있습니다.<br/>
> sudo chown username filename<br/>

이렇게요.<br/>


cf) APT 패키지 관리도구 : 우분투에서는 패키지를 설치 및 관리하기 위해 APT(Advanced Package Tool) 소프트웨어 관리 도구를 사용하며, 패키지 저장소를 통해서 패키지를 다운로드 받습니다.<br/>
cf) 패키지저장소(repository) : 패키지와 패키지 정보 등을 저장하여 집중 관리하는 서버를 말합니다. 저장소의 위치 즉 인덱스 정보는 /etc/apt/sources.list 파일에 저장됩니다.<br/>
저장내용 형식은 deb[deb\-src] URI release section 와 같습니다. <br/>
저장이 되어있어야 우리가 그 패키지를 설치할 수 있어요.<br/>

APT 패키지 관리 명령어들도 더 알아봅시다.<br/>
~~~
apt-get install package명
// 패키지를 다운로드 받아 설치

apt-get source package명
// 소스코드 다운로드

apt-get remove package명
// 설치된 패키지를 삭제

apt-get update
// /etc/apt/sources.list에 저장된 패키지 인덱스 정보 업데이트

apt-get upgrade
// 설치되어있는 패키지를 검사하여 최신 버전으로 업그레이드

apt-get search package명
// 설치되어있는 패키지 검색

apt-cache pkgnames 또는 dpkg -l
// 시스템에 설치되어있는 모든 패키지 목록을 보여줌

apt-cache stats
// 설치된 패키지의 상태정보 출력

apt-cache show package명
// 패키지에 대한 소프트웨어 정보 출력
~~~

아래 명령어를 입력해 x86info라는 패키지를 설치해보는 실습을 해봅시다.<br/>
> sudo apt\-get install x86info<br/>

패키지 설치가 정상적으로 완료된 후 x86info 명령어를 입력하면 CPU에 대한 정보가 출력됩니다.<br/>

리눅스에서 작업을 하다보면 경우에 따라서 /etc/apt/sources.list에 저장소를 추가해야하는 경우가 있습니다.<br/>

그럴 땐 아래명령어를 입력하여 추가하기 전에 먼저 기존 저장소를 백업합니다.<br/>

> sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup<br/>

이후에 새 저장소를 추가하고 업데이트를 진행해줍니다.<br/>
> sudo apt\-get update<br/>

추가 방법은 sources.list파일에서 주석을 제거하거나, add\-apt\-repository 명령을 사용합니다.<br/>
물론 저장 내용의 형식을 맞춰서 작성해줘야겠지요.<br/>
> sudo add\-apt\-repository " deb http://kr.archive.ubuntu.com/ ubuntu/ precise main restricted"<br/>

위 두가지 방법 말고도 ppa(personal package archive) 추가 해야하는 경우도 있습니다.<br/>
말 그대로 우분투 공식 패키지저장소에 없는 개인 패키지 저장소인데요, 이럴땐 아래 명령어를 이용하시면 됩니다.<br/>
> sudo add\-apt\-repository ppa:ondrej/php5<br/>

어떤 방법으로든 추가했다면 업데이트를 진행해주세요.<br/>

2. gzip, gunzip<br/>
* 기능 : 파일을 압축합니다, 압축파일을 압축해제합니다.<br/>
* 형식 : gzip [옵션] 파일명, gunzip [옵션] 파일명<br/>

3. tar<br/>
패키지 배포 등에 많이 사용하게 될 명령어입니다.<br/>
* 기능 : 파일이나 디렉토리를 하나로 묶거나 푼다.<br/>
* 형식 : tar 옵션 파일명 [위치]<br/>
* 옵션<br/>
\-c : 하나의 파일로 묶기(compress)<br/>
\-x : 묶인 파일 풀기(extract)<br/>
\-v : 파일을 묶거나 풀 때 진행 과정을 자세히 보여줌(verbose)<br/>
\-f : 묶음 파일명, tar 명령어를 사용할 때 반드시 사용됨(file)<br/>
\-z : gzip과 관련하여 여러파일들의 압축 및 압축해제를 동시에 수행<br/>

4. man, info<br/>
* 기능 : 도움말 찾기<br/>
* 형식 : man 명령어, info 명령어<br/>
cf) 온라인 매뉴얼도 존재하며 아래에 링크남겨두겠습니다.<br/>
[http://man.he.net/](http://man.he.net/)<br/>

<br/><br/>

사용자 관리
---
리눅스의 모든 파일과 프로그램은 특정 사용자에게 소유됩니다.<br/>
사용자 ID에 기반해서 구분이 되고 배운바와 같이 일반 사용자와 root 사용자인 슈퍼유저가 있습니다.<br/>
사용자 계정 정보는 /etc/passwd에 "로그인이름:패스워드:사용자ID:그룹ID:사용자이름또는코멘트:홈디렉토리:로그인쉘경로명"의 순서로 저장되어있습니다.<br/>

각 사용자는 자신의 홈디렉토리가 있습니다.<br/>
일반적으로 /home/ 밑에 자신의 계정에 해당하는 디렉토리가 있지요.<br/>
홈디렉토리 등은 useradd 명령과 그의 옵션 \-d를 통해 편집이 가능합니다.<br/>

1. chsh<br/>
* 기능 : 디폴트쉘 변경<br/>
* 형식 : chsh \-s /bin/쉘이름<br/>

cf) 쉘: 명령어 라인 해석기(command \-line argument interpreter, CLI)로 운영체제가 수행할 명령어를 직접 입력하는 수단을 제공합니다.<br/>
즉 사용자 인터페이스죠.<br/>
우리가 사용하는 우분투의 쉘 종류는 bourne again shell이라하여 bash라고 부릅니다.<br/>
프롬트 $만 보더라도 알 수 있습니다.<br/>

{% raw %} <img src="https://ohjinjin.github.io/assets/images/20200418bigdata/capture47.JPG" alt=""> {% endraw %}

대개 쉘은 디폴트로 지정이되어있지만, 위 명령어로 변경도 가능합니다.<br/>
$SHELL에는 로그인 shell 절대경로 저장되어 있어서 아래 명령어를 입력하면 확인이 가능합니다.<br/>
> echo $SHELL<br/>

참고로 달러 표시는 환경변수부를 때 앞에 붙이는 것입니다.<br/>

쉘 스크립트 : 쉘 명령들의 리스트로 작성된 파일입니다. 변수값 지정 및 참조 등이 가능합니다.<br/>
chmod를 이용해 쉘 스크립트 파일에 실행권한을 부여해줘야겠지요?<br/>
> chmod \+x 쉘스크립트파일명<br/>
> ./쉘스크립트파일명<br/>

이렇게 실행하시거나 권한이 없는 경우엔 sh 명령으로 실행도 가능합니다.<br/>

사용자가 로그인을 할때 자동으로 실행되는 스크립트들이 있습니다. <br/>
이를 시작 스크립트 또는 startup script라고 부릅니다.<br/>

우분투에서 사용하는 BASH의 시작스크립트는 아래와 같습니다.<br/>
* .profile(또는 bash_profile) : 로그인 쉘로 로그인 후 실행, .bashrc 쉘을 실행하고 명령의 경로등을 지정<br/>
* .bashrc : 비로그인 쉘로 예를들어 터미널을 오픈하는 경우처럼 인증 없이 실행되어 더 많이 사용, 모든 사용자가 공통으로 시작할때 사용하는 환경이 저장된 /etc/bash.bashrc 쉘을 포함(또는 복사), 프롬트 등의 사용자 기본 환경 설정이 이에 추가되어 사용됩니다.<br/>

기타 계정 등록 관련 파일은 /etc/shadow, /etc/group 등이 있습니다.<br/>
전자에는 패스워드 엔트리가 저장되며, 후자에는 각 사용자가 속한 하나 이상의 그룹에 대한 정보를 저장하고 있습니다.<br/>

2. adduser<br/>
* 기능 : 사용자 계정 추가<br/>
* 형식 : adduser 사용자이름<br/>
사용자 계정을 추가할 때에는 수퍼유저로서 etc/passwd를 편집해서 추가할 수도 있지만 adduser 명령을 사용하여 추가할 수도 있습니다.<br/>

3. deluser<br/>
* 기능 : 사용자 계정 제거<br/>
* 형식 : deluser 사용자이름<br/>

4. shutdown<br/>
* 기능 : 시스템 종료<br/>
* 형식 : shutdown [\-t sec] [\-rkhncfF] time [warningMSG]<br/>
* 옵션<br/>
\-k : 실제로 종료하지 않고 모든 사용자에게 경고 메시지만을 전송<br/>
\-r : 시스템 종료 후 재부팅(reboot)<br/>
\-h : shutdown 후 시스템을 종료(halt)<br/>
\-f : 재부팅할 때 fsck(file system check)를 하지 않음<br/>
\-c : shutdown 명령어를 취소<br/>
time : 몇분 후에 시스템을 종료할 것인가를 지정<br/>
warningMSG : 사용자에게 보내질 종료 메시지<br/>
cf) shutdown 뿐아니라 halt, reboot, poweroff 명령어를 이용해도 됩니다.<br/>
가상머신을 사용하는 경우엔 쉽게 종료할 수있고, 저장도해놓을 수 있지만 실제 머신에서는 시스템을 종료할 때에 shutdown이나 위 세 명령어 등을 이용해서 정상적으로 종료시켜주려고 주의해줘야하겠지요.<br/>


<br/>
<br/>
개인이 공부하고 포스팅하는 블로그입니다. 작성한 글 중 오류나 틀린 부분이 있을 경우 과감한 지적 환영합니다!
<br/><br/>